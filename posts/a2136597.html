<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PMP-多边形网格处理-Remeshing | MM's Journal of Technology</title><meta name="author" content="MrMatrix"><meta name="copyright" content="MrMatrix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于Remeshing的一个简单的定义如下：  输入一个3D网格，通过计算得到另一个和输入大致相同且满足一定质量要求网格。  曲面的Remesing目标有以下两点：  根据需求减少曲面的复杂度 改善曲面的质量(Mesh Quality)  曲面的质量(Mesh Quality) 指的是一些 非拓扑属性(Non-Topological Properties) ，例如采样密度，正则性，大小，方位(Or">
<meta property="og:type" content="article">
<meta property="og:title" content="PMP-多边形网格处理-Remeshing">
<meta property="og:url" content="http://mmwiki.cn/posts/a2136597.html">
<meta property="og:site_name" content="MM&#39;s Journal of Technology">
<meta property="og:description" content="关于Remeshing的一个简单的定义如下：  输入一个3D网格，通过计算得到另一个和输入大致相同且满足一定质量要求网格。  曲面的Remesing目标有以下两点：  根据需求减少曲面的复杂度 改善曲面的质量(Mesh Quality)  曲面的质量(Mesh Quality) 指的是一些 非拓扑属性(Non-Topological Properties) ，例如采样密度，正则性，大小，方位(Or">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mmwiki.cn/img/sea.jpg">
<meta property="article:published_time" content="2021-11-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-13T01:55:51.210Z">
<meta property="article:author" content="MrMatrix">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="数字几何处理">
<meta property="article:tag" content="多边形网格处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mmwiki.cn/img/sea.jpg"><link rel="shortcut icon" href="/img/m.png"><link rel="canonical" href="http://mmwiki.cn/posts/a2136597.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PMP-多边形网格处理-Remeshing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-13 09:55:51'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/zhihu.css" media="defer" onload="this.media='all'"><!-- 其他 head 内容--><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/m.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">71</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/sea.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MM's Journal of Technology"><img class="site-icon" src="/img/m.png" alt="Logo"/><span class="site-name">MM's Journal of Technology</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PMP-多边形网格处理-Remeshing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-11-27T16:00:00.000Z" title="发表于 2021-11-28 00:00:00">2021-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/%F0%9F%93%97-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">📗-多边形网格处理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">多边形网格处理</a></div></div><article class="post-content" id="article-container"><p>关于Remeshing的一个简单的定义如下：</p>
<ul>
<li>输入一个3D网格，通过计算得到另一个和输入大致相同且满足一定质量要求网格。</li>
</ul>
<p>曲面的Remesing目标有以下两点：</p>
<ol>
<li>根据需求减少曲面的复杂度</li>
<li>改善曲面的质量(Mesh Quality)</li>
</ol>
<p><em>曲面的质量(Mesh Quality)</em> 指的是一些 <em>非拓扑属性(Non-Topological Properties)</em> ，例如采样密度，正则性，大小，方位(Orientation)，对齐性(原文为Alignment，不太好翻译)，以及曲面网格的形状。</p>
<h2 id="局部结构-Local-Structure"><a href="#局部结构-Local-Structure" class="headerlink" title="局部结构(Local Structure)"></a>局部结构(Local Structure)</h2><p>网格的局部结构(Local Structure)说的是网格元素的种类，形状，方位以及分布情况。</p>
<h3 id="元素的种类-Element-Type"><a href="#元素的种类-Element-Type" class="headerlink" title="元素的种类(Element Type)"></a>元素的种类(Element Type)</h3><p>最为常用的两个种类是 <strong>三角形(Triangle)</strong> 和 <strong>四边形(Quadrangle)</strong> 。</p>
<p>四边形网格可以通过在每一个四边形中插入一条对角线，轻易地转换成三角形网格。</p>
<p>反过来，如果要把三角形网格转换为四边形网格，可以使用重心划分的方法：将三角形的重心和每一条边的中点连接，这样一个三角形就被划分成了3个四边形。另外还有一种方法：将三角形的重心和每一个顶点连接，然后舍弃掉网格上原来所有三角形的边。</p>
<h3 id="元素的形状-Element-Shape"><a href="#元素的形状-Element-Shape" class="headerlink" title="元素的形状(Element Shape)"></a>元素的形状(Element Shape)</h3><p>网格的元素可以分为 <strong>各向同性(Isotropic)</strong> 或者 <strong>各向异性(Anisotropic)</strong> 两类。</p>
<p><strong>各向同性(Isotropic)</strong> 的元素的形状通常在各个方向上一致。理想情况下，当某个三角形(四边形)的元素是或者近似是等边三角形(正方形)时，就说这个元素是各向同性(Isotropic)的。</p>
<p>对于三角形的元素来说，可以通过其外接圆的半径和三边中最短的一条边的比值来度量它具有的各向同性(Isotropic)的强度。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-0.png" alt=""></p>
<h4 id="各向同性-Isotropic-：右图明显比左图更强"><a href="#各向同性-Isotropic-：右图明显比左图更强" class="headerlink" title="各向同性(Isotropic)：右图明显比左图更强"></a>各向同性(Isotropic)：右图明显比左图更强</h4><p><strong>各向异性(Anisotropic)</strong> 的元素在网格曲面上各个方向的形状往往都不同，通常这些元素的都朝向(oriented)主曲率的方向。这种元素往往能够更好的表现几何体的结构特征。它的另一个优势在于，相对于 <strong>各向同性(Isotropic)</strong> ，得到同样质量的网格其使用的元素的个数更少。</p>
<h3 id="元素的密度-Element-Density"><a href="#元素的密度-Element-Density" class="headerlink" title="元素的密度(Element Density)"></a>元素的密度(Element Density)</h3><p>在一个平均分布的网格中(Uniform Distribution)，网格元素平均的分布在整个模型上。在一个不均匀或者适应性分布的网格中(Nonuniform Adaptive Distribution)，每个区域分布的元素的数量都不同，例如比较小的元素通常会较多地处于曲率较高的区域。通过调整，这种不均匀或者适应性分布的网格能够用更少的元素更好地近似出原来的网格。</p>
<h3 id="元素的对齐性和方位-Element-Alignment-and-Orientation"><a href="#元素的对齐性和方位-Element-Alignment-and-Orientation" class="headerlink" title="元素的对齐性和方位(Element Alignment and Orientation)"></a>元素的对齐性和方位(Element Alignment and Orientation)</h3><p>在Remeshing的过程中，一些尖锐突出的地方(Sharp Features)通常会受到影响产生 <em>走样(Aliasing)</em> ，这些地方的切线是不连续的，为了避免这个情况需要将网格元素与它们(Sharp Features)对齐(Align)。</p>
<h2 id="全局结构-Global-Structure"><a href="#全局结构-Global-Structure" class="headerlink" title="全局结构(Global Structure)"></a>全局结构(Global Structure)</h2><p>当三角形网格上非边界上的顶点周围顶点的数量为6或者边界上的顶点周围顶点的数量为4的时候，称这个顶点是 <strong>正则(Regular)</strong> 的。同理对于四边形网格来说，这两个值对应分别是4和3。</p>
<p>相对于 <strong>正则(Regular)</strong>，其它的顶点则是 <strong>非正则(Irregular)</strong> 或者 <strong>Extraordinary</strong>。</p>
<p>网格的全局结构可以根据正则顶点的数目被分为 <strong>非正则(Irregular)</strong> ，<strong>半正则(Semiregular)</strong> ，<strong>高度正则(Highly Regular)</strong> 和 <strong>正则(Regular)</strong> 四种。</p>
<h2 id="一致性-Correspondences"><a href="#一致性-Correspondences" class="headerlink" title="一致性(Correspondences)"></a>一致性(Correspondences)</h2><p>所有Remeshing算法，都会在曲面上或者曲面附近计算点的位置。其中大部分算法甚至还会进行额外的迭代来修正顶点的位置以改善网格的质量。所以在Remeshing的过程中一个关键的问题就是要保证计算前后顶点的一致性。</p>
<p>下面有几种解决这个问题的方法：</p>
<ul>
<li><p><strong>全局参数化(Global parameterization)</strong>：将输入的模型整个参数化到一个2维参数域上，然后在这个参数域对采样点的分布和位置进行调整，最后再将其还原到3维空间中。</p>
</li>
<li><p><strong>局部参数化(Local parameterization)</strong>：算法只保留某个点局部的参数化信息，当采样点变换的时候，再去计算那个点的局部参数化信息。</p>
</li>
<li><p><strong>投影(Projection)</strong>：将采样点投影到输入模型上对应最近的顶点、边或者三角形上。</p>
</li>
</ul>
<p>全局参数化的计算相对来说比较耗时，同时当模型被切开成一个圆盘(Disk)的时候。</p>
<p>而当采样点离曲面太远的时候，直接进行投影则可能会导致重影现象。通过将对采样点的移动限制在切平面上使得采样点不会原来曲面太远，以解决上述问题。</p>
<p>局部参数化方法相对稳定，并且效果较好，不过需要不断的跟踪记录并重新计算局部的参数化信息。</p>
<h2 id="沃罗诺伊图和德洛内三角剖分-Voronoi-Diagrams-and-Delaunay-Triangulations"><a href="#沃罗诺伊图和德洛内三角剖分-Voronoi-Diagrams-and-Delaunay-Triangulations" class="headerlink" title="沃罗诺伊图和德洛内三角剖分(Voronoi Diagrams and Delaunay Triangulations)"></a>沃罗诺伊图和德洛内三角剖分(Voronoi Diagrams and Delaunay Triangulations)</h2><p><strong>沃罗诺伊图(Voronoi Diagrams)</strong>，简单的说就是基于一组 <strong>特定点</strong> 将空间分割成不同的区域，而每一个区域都只包含这些点中的一个，并且该区域内的任意点到这个 <strong>特定点</strong> 的距离 <strong>小于</strong> 该这个任意点到空间中其它 <strong>特定点</strong> 的距离。其中这些被分割的区域称作 <strong>沃罗诺伊区域(Voronoi Region)</strong>。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-1.gif" alt=""></p>
<p>上面这张图形象的描述了 <strong>沃罗诺伊图</strong> 的生成过程。</p>
<p>下面我们用数学的形式来表达 <strong>沃罗诺伊区域</strong> 。给定任意维空间Rd上的一个点的集合p1,…,pn，点pi的 <strong>沃罗诺伊区域</strong> V(pi) 是：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-2.png" alt=""></p>
<p><strong>沃罗诺伊图</strong> 可以看作空间Rd上的一个划分，因为该空间上任意一个点必定属于某一个 <strong>沃罗诺伊区域</strong> 。</p>
<p>与该空间中的任意两个点pi和pj等距的点组成的区域被称作 <strong>Bisector</strong> ，所有的 <strong>Bisector</strong> 都是该空间上的仿射子空间(Affine Subspace)。例如，在2维空间上Bisector是一条线，3维空间上Bisector是一个面。</p>
<p>从Bisector的定义可以看出，<strong>沃罗诺伊区域</strong> 也可以被定义为由一些 <strong>Bisector</strong> 的半空间(Half-Space)相交所围成的闭合区域，因为凸集(Convex Set)相交仍仍然是凸的，所以 <strong>沃罗诺伊区域</strong> 是一个凸集。不过在靠近整个空间Rd边缘的区域，闭合组成 <strong>沃罗诺伊区域</strong> 的Bisector里就会包含Rd的外壳(Hull)部分。</p>
<p><strong>沃罗诺伊图</strong> 的对偶结构被称为 <strong>德洛内三角剖分(Delaunay Triangulations)</strong>。通过连接沃罗诺伊区域内的顶点可以得到其对应的对偶结构，如下图所示：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-3.png" alt=""></p>
<p><strong>德洛内三角剖分</strong> 的 <strong>三角形</strong> (p,q,r)与 <strong>沃罗诺伊区域</strong> V(p)，V(q)，V(r)相交得到的 <strong>顶点</strong> 对偶。</p>
<p><strong>德洛内三角剖分</strong> 的 <strong>边</strong> (p,q)与 <strong>沃罗诺伊区域</strong> V(p)，V(q)相交得到的 <strong>边</strong> 对偶。</p>
<p><strong>德洛内三角剖分</strong> 的 <strong>顶点</strong> p 与 <strong>沃罗诺伊区域</strong> V(p)对偶。</p>
<p>可以发现 <strong>德洛内三角剖分</strong> 和 <strong>沃罗诺伊图</strong> 在许多局部和全局的属性上存在对偶关系，如：</p>
<ul>
<li><p>对于k维空间上的某个点集P上的 <strong>德洛内三角剖分</strong> ，其上的任何一个k单纯形(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simplex">k-simplex</a>：即在k维空间上，由k+1个点组成的多面体，如2维空间上的三角形，3维空间上的四面等)的外界圆(因为是任意维的情况，所以称作超球面更准确一些)的内部都不包含点集上其它的点。</p>
</li>
<li><p>对于2维空间上的某个点集P上的 <strong>德洛内三角剖分</strong> ，这种剖分能够最大化所有三角形中最小的角。</p>
</li>
</ul>
<p>另外在进行 <strong>德洛内三角剖分</strong> 的时候还可以对其加以限制，例如在2维空间上可以用闭合的平面曲线来进行限制，在3维空间上用闭合曲面来进行限制。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-4.png" alt=""></p>
<h4 id="蓝色的曲线是作为限制的闭合曲线，红色的直线是与之相交的沃罗诺伊图的边"><a href="#蓝色的曲线是作为限制的闭合曲线，红色的直线是与之相交的沃罗诺伊图的边" class="headerlink" title="蓝色的曲线是作为限制的闭合曲线，红色的直线是与之相交的沃罗诺伊图的边"></a>蓝色的曲线是作为限制的闭合曲线，红色的直线是与之相交的沃罗诺伊图的边</h4><h2 id="三角形网格的网格重划分-Triangle-Based-Remeshing"><a href="#三角形网格的网格重划分-Triangle-Based-Remeshing" class="headerlink" title="三角形网格的网格重划分(Triangle-Based Remeshing)"></a>三角形网格的网格重划分(Triangle-Based Remeshing)</h2><h3 id="Greedy-Remeshing"><a href="#Greedy-Remeshing" class="headerlink" title="Greedy Remeshing"></a>Greedy Remeshing</h3><p>这个方法的主要思想是对 <strong>3维德洛内三角剖分</strong> 的 <strong>Refining</strong> 和提取 <strong>Filtering</strong> 。</p>
<p>在 <strong>Refining</strong> 的过程中，输入网格上的点会被选中然后插入到德洛内三角剖分的三角形中。而点的位置则是网格曲面与德洛内三角剖分对应的沃罗诺伊图的边的交点。换句话说沃罗诺伊图的边被用来当作输入网格曲面的“探针(Probe)”。</p>
<p>在 <strong>Filtering</strong> 的过程中，更新德洛内三角剖分使其被限制在曲面上，即选取德洛内三角剖分的面，与这些面对偶的沃罗诺伊图的边与该曲面相交。</p>
<p>该算法会涉及下面的概念：</p>
<ul>
<li><p><strong>Surface Delaunay ball</strong> 一个Surface Delaunay ball是一个位于输入网格曲面中心的球，这个球包围了一个德洛内三角剖分中的一个特定的面。一个中心位置为c，半径为r，包围了面f的Surface Delaunay ball可以记作： <img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-5.png" alt=""></p>
</li>
<li><p><strong>Medial axis</strong> 给定n维空间上的一个集合O，它的Medial axis M(O)是一系列点的集合，以这些点为中心的超球面与集合O的边界相切的点的个数至少为2。</p>
</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-6.png" alt=""></p>
<h4 id="椭圆区域为O，中间的直线为Medial-axis"><a href="#椭圆区域为O，中间的直线为Medial-axis" class="headerlink" title="椭圆区域为O，中间的直线为Medial axis"></a>椭圆区域为O，中间的直线为Medial axis</h4><ul>
<li><strong>Medial ball</strong> 中心在Medial axis上的球(ball)，其内部被集合O包含并且它的包围球面与O的边界相交，称这样的球(ball)为Medial ball。</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-7.png" alt=""></p>
<h4 id="最外侧的实线包含的集合为O，集合内的实线为Medial-axis，圆圈所围成的区域为Medial-ball"><a href="#最外侧的实线包含的集合为O，集合内的实线为Medial-axis，圆圈所围成的区域为Medial-ball" class="headerlink" title="最外侧的实线包含的集合为O，集合内的实线为Medial axis，圆圈所围成的区域为Medial ball"></a>最外侧的实线包含的集合为O，集合内的实线为Medial axis，圆圈所围成的区域为Medial ball</h4><ul>
<li><strong>Reach(Local feature size)</strong> 集合O内的点x到集合O上的Medial axis的距离称为Reach或者Local feature size。</li>
</ul>
<p>有了上面的定义就可以准确的描述Refine的过程，即调整带限制的德洛内三角剖分，使得所有的 <em>Surface Delaunay ball</em> 的半径都小于局部的 <em>Reach</em> ，为了保证算法能够正确终止还需要确保 <em>Reach</em> 大于0。</p>
<p>算法需要一个点集P，P的德洛内三角剖分Del(P)，带限制条件的德洛内三角剖分DelS(P)，以及DelS(P)中“不好(bad)”的面的列表L。</p>
<p><strong>“不好(bad)”的面</strong> 的定义为：假定有一个Surface Delaunay ball—— Bf\=B(cf，rf)，满足rf>Ψ(cf)，其中Ψ是定义在S上的函数，Ψ满足下列条件：存在S上的一个点x，使得</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-8.png" alt=""></p>
<p>初始化的时候点集P选取S中每个联通区域上足够近的三个点，然后执行下面的算法</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-9.png" alt=""></p>
<p>当Ψ满足，其中ϵ\=0.2，ρ\=reach，上面的算法会在经过有限次的迭代之后终止，并且算法输出的结果——带限制的3维德洛内三角剖分与输入的网格曲面相互同胚。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-10.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-11.png" alt=""></p>
<h4 id="左图为原模型，右图为算法处理后的模型"><a href="#左图为原模型，右图为算法处理后的模型" class="headerlink" title="左图为原模型，右图为算法处理后的模型"></a>左图为原模型，右图为算法处理后的模型</h4><p>上述算法由于大量涉及到求直线和三角形面求交的过程，所以可以使用八叉树的数据结构进行加速。</p>
<p>Greedy Remeshing的优点在于其结果保证不会出现自相交，因为三角形网格是取自与三维德洛内三角剖分的。Greedy Remeshing另外一个很好的地方在于他不需要局部或者全局的参数化信息。</p>
<p>那么如果想要使用尽量少的顶点得到质量尽可能高的网格，该怎么做呢？下面的Variational Remeshing方法能够部分解决这个问题。</p>
<h3 id="Variational-Remeshing"><a href="#Variational-Remeshing" class="headerlink" title="Variational Remeshing"></a>Variational Remeshing</h3><p>当我们寻求高质量的网格的时候，就需要对网格进行相应的优化工作。</p>
<ul>
<li><strong>优化的标准是什么？</strong> 一些和形状、三角大小等相关的几何量</li>
<li><strong>自由度是多少</strong> ？尽可能的少。</li>
</ul>
<p>Variational Remeshing地主要思想是：将一系列的点尽可能平均地放置到输入地网格之上。</p>
<p>以2D的情况为例，如果要平均地将一系列点放置到一个平面上，其中一个方法就是通过构建一个 <strong>Centroidal Voronoi Tessellation(CVT)</strong> 来实现。</p>
<p>给定一个边界域Ω，如果存在一个被Ω限制的 <strong>沃罗诺伊划分(Voronoi Tessellation)</strong> ，其上的任意一个沃罗诺伊区域中的顶点刚好是这个区域的重心，那么称这个这个划分为 <strong>Centroidal Voronoi Tessellation(CVT)</strong>。</p>
<p>求一个沃罗诺伊区域Vi的重心ci的方法如下：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-12.png" alt=""></p>
<p>ρ(x)是的密度函数，通常取一个常数(即区域内的质量分布是均匀的)。</p>
<p>Variational Algorithm即变分算法通常需要首先定义一个能量函数，然后通过不断地迭代最小化这个能量函数。</p>
<p>这里我们定义如下地能量函数：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-13.png" alt=""></p>
<p>通过观察可以知道，当pi是对应沃罗诺伊区域Vi上的重心的时候，上面的能量函数取最小值。</p>
<p>我们可以使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lloyd%27s_algorithm">Lloyd’s Algorithm</a>(也叫Lloyd’s Relaxation Method)，通过不断迭代建立一个 <strong>CVT</strong> 。给定一个密度函数ρ和一个点集 pi，算法由下面三个步骤组成：</p>
<ol>
<li>根据点集pi建立沃罗诺伊划分(Voronoi Tessellation)</li>
<li>计算每一个沃罗诺伊区域的重心ci，然后将pi移动到ci的位置</li>
<li>重复执行(1)(2)直到满足收敛条件</li>
</ol>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-14.png" alt=""></p>
<h4 id="从左到右：原始的沃罗诺伊划分；经过一次迭代后的划分；经过三次迭代的划分；Centroidal-Voronoi-Tessellation-CVT"><a href="#从左到右：原始的沃罗诺伊划分；经过一次迭代后的划分；经过三次迭代的划分；Centroidal-Voronoi-Tessellation-CVT" class="headerlink" title="从左到右：原始的沃罗诺伊划分；经过一次迭代后的划分；经过三次迭代的划分；Centroidal Voronoi Tessellation(CVT)"></a>从左到右：原始的沃罗诺伊划分；经过一次迭代后的划分；经过三次迭代的划分；Centroidal Voronoi Tessellation(CVT)</h4><p>为了能够在3D网格上应用同样的算法，我们先将网格进行保角参数化，然后在参数空间上应用Lloyd’s Algorithm。参数化的过程中会导致三角形变形，密度函数 <em>ρ</em> 在这里就被用来抵消这种变形，通过在多个带边界限制的沃罗诺伊图上分别应用Lloyd’s Algorithm，网格上一些诸如褶皱、夹角的特征能够得到保留。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-15.png" alt=""></p>
<h3 id="Incremental-Remeshing"><a href="#Incremental-Remeshing" class="headerlink" title="Incremental Remeshing"></a>Incremental Remeshing</h3><p>Incremental Remeshing相较于之前的Variational Remeshing来说实现起来更加简单——它不需要进行参数化并且不需要进行划分(Tessellation)。</p>
<p>算法首先输入一个目标边长(Target Edge Length)，然后根据这个输入对网格中较长的边进行Split操作，对较短的边进行Collapse操作，并且会移动顶点的位置，直到所有边的长度和输入的目标边长(Target Edge Length)大致相当。算法的伪代码如下：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-16.png" alt=""></p>
<p>注意到我们通过输入的长度得到一个区间[low,high]，如果边长在区间左侧则认为这条边太短需要进行Collapse操作；如果边长在区间的右侧则认为这条边太长，需要进行Split操作。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-17.png" alt=""></p>
<h4 id="网格的基本操作"><a href="#网格的基本操作" class="headerlink" title="网格的基本操作"></a>网格的基本操作</h4><p><strong>split_long_edges(high)</strong> 函数会遍历当前网格中所有的边，如果其长度大于high，那么我们就从这条边的中点对其进行Split操作。操作之后，和这条边相邻的两个三角形都会被一分为二。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-18.png" alt=""></p>
<p><strong>collapse_short_edges(low, high)</strong> 函数同样对当前网格的所有边进行遍历，对长度小于low的边进行Collapse操作。不过需要注意的一点是，在进行Collapse操作的时候需要检查经过该操作是否会产生长度大于high的边，如果不产生，那么我们进行此次的Collapse操作，否则不进行。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-19.png" alt=""></p>
<p><strong>equalize_valences()</strong> 函数对边进行Flip操作来调整各个顶点的Valence(于该顶点相邻的顶点的个数)，使其尽量地接近目标Valence。函数会遍历当前网格的所有边，并尝试对其进行Flip操作，然后比较Flip操作前后和这条边相邻的两个三角形上的四个顶点其Valence和目标值的偏差，如果偏差没有变小那么撤销之前的Flip操作(对这条边再进行一次Flip操作)。</p>
<p><strong>target_val(v)</strong> 函数接受一个顶点做为输入，如果该顶点是边界上的点那么函数返回4，如果是内部的点则返回6。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-20.png" alt=""></p>
<p><strong>tangential_relaxation()</strong> 函数对当前的网格进行反复的平滑过滤。假定p是网格上的某一个点，n是该点的法线量，然后使用下面的方法计算出点q ：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-21.png" alt=""></p>
<p>然后我们将q向p点的方向投影，得到p的新位置：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-22.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-23.png" alt=""></p>
<p><strong>project_to_surface()</strong> 函数将顶点投影到原曲面上。</p>
<p>为了保证输入模型的特征，在进行上面的算法的时候需要加入一些限制：</p>
<ul>
<li><p>角上的顶点(Corner Vertices)对应的一个或两个特征边(Feature Edge)必需被保留，并且不对其进行任何可以改变其几何或者拓扑结构的操作。</p>
</li>
<li><p>对一个特征边(Feature Edge)进行Split操作将得到两个特征边(Feature Edge)和一个特征点(Feature Vertex)。</p>
</li>
<li><p>对特征边(Feature Edge)进行 <strong>tangential_relaxation()</strong> 函数的时候，只能在这条边的方向上进行。</p>
</li>
<li><p>对处于特征边(Feature Edge)的点进行Collapse操作的时候只能在沿着这条边的方向上进行该操作。</p>
</li>
<li><p>不能对特征边(Feature Edge)进行Flip操作</p>
</li>
</ul>
<h2 id="四边形网格的网格重划分-Quad-dominant-Remeshing"><a href="#四边形网格的网格重划分-Quad-dominant-Remeshing" class="headerlink" title="四边形网格的网格重划分(Quad-dominant Remeshing)"></a>四边形网格的网格重划分(Quad-dominant Remeshing)</h2><p>生成四边形网格的思路主要有下面几种：</p>
<ul>
<li><p>四边形化(Quadrangulation)：通过放置一些列的点，然后将其四边形化(通过添加Steiner Point或者使用Circle Packing法)。不过缺点在于缺乏对边朝向性(orientation)和对齐性(alignment)的控制。</p>
</li>
<li><p>转化(Conversion)：首先生成三角形网格或者多边形网格，然后将其转换维四边形网格。转换的具体方法有：合并与一条边相邻的两个三角形 ，切分多边形网格等。这种方法能够简单地控制边的朝向性和对齐性。</p>
</li>
<li><p>基于曲线的采样(Curve-based Sampling)：通过放置一系列与方向场相切的曲线来生成一个曲线网络，这样网络上的每一个交点正好是生成的顶点。此方法能够很好的控制边的朝向性和对齐性，不过生成的四边形网格上可能会有T-Junction，所以并不完全是一个四边形网格。</p>
</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-24.png" alt=""></p>
<h4 id="T-Junction"><a href="#T-Junction" class="headerlink" title="T-Junction"></a>T-Junction</h4><ul>
<li>等值线法(Contouring)：一个能得到纯四边形网格(Pure Quadrangle Mesh)的方法包含有如下：计算两个标量函数、将经过选取的一系列等值带入这两个函数中从而得到四边形网格的一些列小四边形。</li>
</ul>
<p>这里我们将讨论的方法基于后两点，该方法包含三个主要步骤：</p>
<ul>
<li>首先计算每个顶点的曲率张量(Curvature Tensor)来还原出一个连续(continuous)的模型。计算完张量之后，丢弃掉其中法向量的分量。然后通过计算离散保角参数化(Discrete Conformal Parameterization)得到了一个2维分段张量场，然后对其使用高斯核函数做卷积运算，得到一个平滑的曲率方向场，并且提取出张量场中的脐点(Umbilics)。</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-25.png" alt=""></p>
<h4 id="曲率张量"><a href="#曲率张量" class="headerlink" title="曲率张量"></a>曲率张量</h4><p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-26.png" alt=""></p>
<h4 id="左图：初始主方向场；右图：平滑后的主方向场；图中彩色的点为脐点"><a href="#左图：初始主方向场；右图：平滑后的主方向场；图中彩色的点为脐点" class="headerlink" title="左图：初始主方向场；右图：平滑后的主方向场；图中彩色的点为脐点"></a>左图：初始主方向场；右图：平滑后的主方向场；图中彩色的点为脐点</h4><ul>
<li>第二步是在参数空间上上进行重新采样。对于各向异性的区域(Anisotropic Area)，建立由一些列曲率线(沿着主曲率的方法)组成的网格；而对于各向同性的区域(Isotropic Area)则使用普通的顶点采样的方法</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note6-Remeshing/img-27.png" alt=""></p>
<ul>
<li>最后一步通过第二部采样出来的点获得边，在各向异性的区域我们将曲率线拉直以得到边，在各向同性的区域我们通过德洛内三角剖分来获得边。最终得到的多边形网格中既包含三角形也包含了四边形。</li>
</ul>
<p>不过对于平坦的区域，由于曲率线之间的距离很大，可能最后不会产生任何的多边形。因此当曲率线进入一个较为平坦的区域的时候，算法使从其上一个采样点开始沿着测地线(Geodesic Curve)的方向延长，直到其进入较为弯曲的区域。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">blauhimmel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">https://blauhimmel.github.io/tags/polygon-mesh-processing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归原作者所有，如有转载，请注明来自原作者</span></div></div><div class="post_share"><div class="social-share" data-image="/img/sea.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2f7573f8.html" title="中科大-数字几何处理-纹理映射"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">中科大-数字几何处理-纹理映射</div></div></a></div><div class="next-post pull-right"><a href="/posts/fb27f376.html" title="中科大-数字几何处理-Morphing与配准"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">中科大-数字几何处理-Morphing与配准</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/850c08c.html" title="PMP-多边形网格处理-写在后面"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">PMP-多边形网格处理-写在后面</div></div></a></div><div><a href="/posts/85887e2a.html" title="PMP-多边形网格处理-曲面的表示"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">PMP-多边形网格处理-曲面的表示</div></div></a></div><div><a href="/posts/d5619342.html" title="PMP-多边形网格处理-网格数据结构"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-01</div><div class="title">PMP-多边形网格处理-网格数据结构</div></div></a></div><div><a href="/posts/1ba09c44.html" title="PMP-多边形网格处理-曲面平滑"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-16</div><div class="title">PMP-多边形网格处理-曲面平滑</div></div></a></div><div><a href="/posts/6b345a08.html" title="PMP-多边形网格处理-参数化"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-07</div><div class="title">PMP-多边形网格处理-参数化</div></div></a></div><div><a href="/posts/820ec93f.html" title="PMP-多边形网格处理-微分几何"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-26</div><div class="title">PMP-多边形网格处理-微分几何</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/m.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MrMatrix</div><div class="author-info__description">To be a better man.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">71</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.zhihu.com/people/MrMatrix"><i></i><span>知乎</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个博客是为了记录自己在科研👨‍🔬、工作👨‍💻和生活👨‍👩‍👧‍👦的过程中捕获到的有价值的课程📺、书籍📗与事件📰，是面向我自己搭建的查漏补缺的备忘录📝和记事本📓✏️。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%BB%93%E6%9E%84-Local-Structure"><span class="toc-number">1.</span> <span class="toc-text">局部结构(Local Structure)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E7%A7%8D%E7%B1%BB-Element-Type"><span class="toc-number">1.1.</span> <span class="toc-text">元素的种类(Element Type)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%A2%E7%8A%B6-Element-Shape"><span class="toc-number">1.2.</span> <span class="toc-text">元素的形状(Element Shape)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7-Isotropic-%EF%BC%9A%E5%8F%B3%E5%9B%BE%E6%98%8E%E6%98%BE%E6%AF%94%E5%B7%A6%E5%9B%BE%E6%9B%B4%E5%BC%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">各向同性(Isotropic)：右图明显比左图更强</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E5%AF%86%E5%BA%A6-Element-Density"><span class="toc-number">1.3.</span> <span class="toc-text">元素的密度(Element Density)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E5%AF%B9%E9%BD%90%E6%80%A7%E5%92%8C%E6%96%B9%E4%BD%8D-Element-Alignment-and-Orientation"><span class="toc-number">1.4.</span> <span class="toc-text">元素的对齐性和方位(Element Alignment and Orientation)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%BB%93%E6%9E%84-Global-Structure"><span class="toc-number">2.</span> <span class="toc-text">全局结构(Global Structure)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-Correspondences"><span class="toc-number">3.</span> <span class="toc-text">一致性(Correspondences)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%9B%BE%E5%92%8C%E5%BE%B7%E6%B4%9B%E5%86%85%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86-Voronoi-Diagrams-and-Delaunay-Triangulations"><span class="toc-number">4.</span> <span class="toc-text">沃罗诺伊图和德洛内三角剖分(Voronoi Diagrams and Delaunay Triangulations)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%93%9D%E8%89%B2%E7%9A%84%E6%9B%B2%E7%BA%BF%E6%98%AF%E4%BD%9C%E4%B8%BA%E9%99%90%E5%88%B6%E7%9A%84%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF%EF%BC%8C%E7%BA%A2%E8%89%B2%E7%9A%84%E7%9B%B4%E7%BA%BF%E6%98%AF%E4%B8%8E%E4%B9%8B%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%9B%BE%E7%9A%84%E8%BE%B9"><span class="toc-number">4.0.1.</span> <span class="toc-text">蓝色的曲线是作为限制的闭合曲线，红色的直线是与之相交的沃罗诺伊图的边</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BD%91%E6%A0%BC%E7%9A%84%E7%BD%91%E6%A0%BC%E9%87%8D%E5%88%92%E5%88%86-Triangle-Based-Remeshing"><span class="toc-number">5.</span> <span class="toc-text">三角形网格的网格重划分(Triangle-Based Remeshing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Greedy-Remeshing"><span class="toc-number">5.1.</span> <span class="toc-text">Greedy Remeshing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E5%8C%BA%E5%9F%9F%E4%B8%BAO%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%9A%84%E7%9B%B4%E7%BA%BF%E4%B8%BAMedial-axis"><span class="toc-number">5.1.1.</span> <span class="toc-text">椭圆区域为O，中间的直线为Medial axis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%96%E4%BE%A7%E7%9A%84%E5%AE%9E%E7%BA%BF%E5%8C%85%E5%90%AB%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%BAO%EF%BC%8C%E9%9B%86%E5%90%88%E5%86%85%E7%9A%84%E5%AE%9E%E7%BA%BF%E4%B8%BAMedial-axis%EF%BC%8C%E5%9C%86%E5%9C%88%E6%89%80%E5%9B%B4%E6%88%90%E7%9A%84%E5%8C%BA%E5%9F%9F%E4%B8%BAMedial-ball"><span class="toc-number">5.1.2.</span> <span class="toc-text">最外侧的实线包含的集合为O，集合内的实线为Medial axis，圆圈所围成的区域为Medial ball</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%9B%BE%E4%B8%BA%E5%8E%9F%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8F%B3%E5%9B%BE%E4%B8%BA%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">左图为原模型，右图为算法处理后的模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variational-Remeshing"><span class="toc-number">5.2.</span> <span class="toc-text">Variational Remeshing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%88%92%E5%88%86%EF%BC%9B%E7%BB%8F%E8%BF%87%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3%E5%90%8E%E7%9A%84%E5%88%92%E5%88%86%EF%BC%9B%E7%BB%8F%E8%BF%87%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%88%92%E5%88%86%EF%BC%9BCentroidal-Voronoi-Tessellation-CVT"><span class="toc-number">5.2.1.</span> <span class="toc-text">从左到右：原始的沃罗诺伊划分；经过一次迭代后的划分；经过三次迭代的划分；Centroidal Voronoi Tessellation(CVT)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Incremental-Remeshing"><span class="toc-number">5.3.</span> <span class="toc-text">Incremental Remeshing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.1.</span> <span class="toc-text">网格的基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E7%9A%84%E7%BD%91%E6%A0%BC%E9%87%8D%E5%88%92%E5%88%86-Quad-dominant-Remeshing"><span class="toc-number">6.</span> <span class="toc-text">四边形网格的网格重划分(Quad-dominant Remeshing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Junction"><span class="toc-number">6.0.1.</span> <span class="toc-text">T-Junction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%8E%87%E5%BC%A0%E9%87%8F"><span class="toc-number">6.0.2.</span> <span class="toc-text">曲率张量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%9B%BE%EF%BC%9A%E5%88%9D%E5%A7%8B%E4%B8%BB%E6%96%B9%E5%90%91%E5%9C%BA%EF%BC%9B%E5%8F%B3%E5%9B%BE%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%90%8E%E7%9A%84%E4%B8%BB%E6%96%B9%E5%90%91%E5%9C%BA%EF%BC%9B%E5%9B%BE%E4%B8%AD%E5%BD%A9%E8%89%B2%E7%9A%84%E7%82%B9%E4%B8%BA%E8%84%90%E7%82%B9"><span class="toc-number">6.0.3.</span> <span class="toc-text">左图：初始主方向场；右图：平滑后的主方向场；图中彩色的点为脐点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6382afc7.html" title="观陶哲轩演讲-AI与数学-后有感">观陶哲轩演讲-AI与数学-后有感</a><time datetime="2024-08-29T16:00:00.000Z" title="发表于 2024-08-30 00:00:00">2024-08-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b9a84247.html" title="国科大-随机过程-写在后面">国科大-随机过程-写在后面</a><time datetime="2024-01-28T16:00:00.000Z" title="发表于 2024-01-29 00:00:00">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4309bd24.html" title="国科大-随机过程-连续时间马尔可夫链">国科大-随机过程-连续时间马尔可夫链</a><time datetime="2024-01-27T16:00:00.000Z" title="发表于 2024-01-28 00:00:00">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b497123d.html" title="国科大-随机过程-马尔可夫链的转移概率与极限行为">国科大-随机过程-马尔可夫链的转移概率与极限行为</a><time datetime="2024-01-20T16:00:00.000Z" title="发表于 2024-01-21 00:00:00">2024-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8d52a7e7.html" title="国科大-随机过程-马尔可夫链中的常反性及其相关概念">国科大-随机过程-马尔可夫链中的常反性及其相关概念</a><time datetime="2024-01-15T16:00:00.000Z" title="发表于 2024-01-16 00:00:00">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sea.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By MrMatrix</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn"><span>浙ICP备2024121111号</span></a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/"><img class="icp-icon" src="http://www.beian.gov.cn/img/new/gongan.png"/><span>浙公网安备33010802013618号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams'
        },
        chtml: {
          scale: 1.1
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div><script src="/js/category.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":false},"react":{"opacity":0.85},"log":false});</script></body></html>