<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP-【第二章】信息的表示和处理-补充阅读与总结【转载】 | MM's Journal of Technology</title><meta name="author" content="MrMatrix"><meta name="copyright" content="MrMatrix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="补充阅读材料： https:&#x2F;&#x2F;fengmuzi2003.gitbook.io&#x2F;csapp3e&#x2F;di-er-zhang-zhong-dian-jie-du 学习目标  理解计算机系统的复杂与和理论抽象描述的不同 理解内存中数据的保存形式，以及这种方式的好处以及限制 注意避开一些常见的关于计算机的迷思 区别整型和浮点数的表达机制，并理解为什么会有这种差异 简单理解溢出出现的条件  编程迷思 无论是计">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP-【第二章】信息的表示和处理-补充阅读与总结【转载】">
<meta property="og:url" content="http://mmwiki.cn/posts/4ef1ce7c.html">
<meta property="og:site_name" content="MM&#39;s Journal of Technology">
<meta property="og:description" content="补充阅读材料： https:&#x2F;&#x2F;fengmuzi2003.gitbook.io&#x2F;csapp3e&#x2F;di-er-zhang-zhong-dian-jie-du 学习目标  理解计算机系统的复杂与和理论抽象描述的不同 理解内存中数据的保存形式，以及这种方式的好处以及限制 注意避开一些常见的关于计算机的迷思 区别整型和浮点数的表达机制，并理解为什么会有这种差异 简单理解溢出出现的条件  编程迷思 无论是计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mmwiki.cn/img/sea.jpg">
<meta property="article:published_time" content="2020-12-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-31T09:16:58.120Z">
<meta property="article:author" content="MrMatrix">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="深入理解计算机系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mmwiki.cn/img/sea.jpg"><link rel="shortcut icon" href="/img/m.png"><link rel="canonical" href="http://mmwiki.cn/posts/4ef1ce7c.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP-【第二章】信息的表示和处理-补充阅读与总结【转载】',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-31 17:16:58'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/zhihu.css" media="defer" onload="this.media='all'"><!-- 其他 head 内容--><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/m.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">188</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">63</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/sea.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MM's Journal of Technology"><img class="site-icon" src="/img/m.png" alt="Logo"/><span class="site-name">MM's Journal of Technology</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP-【第二章】信息的表示和处理-补充阅读与总结【转载】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-12-09T16:00:00.000Z" title="发表于 2020-12-10 00:00:00">2020-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%AE%97%E6%B3%95/">编程与算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">书籍阅读-深入理解计算机系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">深入理解计算机系统</a></div></div><article class="post-content" id="article-container"><p>补充阅读材料：<br>
<a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du">https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du</a></p>
<h2 id="学习目标">学习目标</h2>
<ol>
<li>理解计算机系统的复杂与和理论抽象描述的不同</li>
<li>理解内存中数据的保存形式，以及这种方式的好处以及限制</li>
<li>注意避开一些常见的关于计算机的迷思</li>
<li>区别整型和浮点数的表达机制，并理解为什么会有这种差异</li>
<li>简单理解溢出出现的条件</li>
</ol>
<h2 id="编程迷思">编程迷思</h2>
<p>无论是计算机科班出身的学生，还是半路出家的爱好者，因为现在编程难度的大幅度降低，很多时候并不需要理解底层的实现就已经可以写出过得去的代码。但是网上的一些错误理解以及教材中由于内容编排对概念所做的抽象，导致了许多『想当然』的问题。要深入理解计算机系统，得先把这些『迷思』弄清楚，这样接下来的旅程会好走很多。</p>
<h3 id="计算机不只是执行程序的机器">计算机不只是执行程序的机器</h3>
<p>计算机脱胎于图灵机的构想，简单来说，就是能够执行有限逻辑数学过程的计算模型。图灵机的概念很有意思，但是这里由于篇幅问题不再深入，感兴趣的话可以从维基百科[1]入门，然后就可以看看《图灵的秘密》[2]这本书，从生平到提出图灵机的论文研读都非常不错。</p>
<p>图灵机中最重要的两个『物理』硬件是纸带和读写头（这里的『物理』指的是相对于图灵机其他部分而言）。这种抽象非常简单明了，但是很容易给人一种错误印象，即由图灵机发展而来的现代计算机，就是执行程序的机器而已。</p>
<p>计算机学科的发展，与其说是众人拾柴火焰高，不如说是天才引导的历程。真正奠定现代计算机基础的则是冯诺依曼[3]，1945 年发表的 101 页报告[4]，不但提出了二进制的构想，更将计算机分成五大组件（存储器、控制器、运算器、输入、输出），我们现在使用的大部分计算机都符合冯诺依曼架构，『计算机之父』之名绝不为过。</p>
<p>当然，这个世界上总是少不了『既生瑜，何生亮』的桥段，与冯诺依曼架构（也称为普林斯顿架构）一时瑜亮另一种架构叫做哈佛架构[5]，它和冯诺依曼架构最大的区别在于能够同时访问数据和指令。虽然在计算机体系架构中黯然退场，但是哈佛结构在移动计算中扮演了非常重要的角色，ARM 架构可能是知名度最高的当红炸子鸡了。</p>
<p>和图灵机相比，这两种架构最重要的突破就是增加的存储器，这使得程序和数据的存储成为可能，也因此衍生出来了数据传输（即 IO）的概念，再加上六十年代末出现的计算机网络，计算机要完成的工作，远不止执行程序这么简单。</p>
<p>凡事有利有弊，冯诺依曼架构也有缺陷，甚至可以这么理解，目前计算机系统的诸多漏洞和不稳定，是在设计之初就注定的。比方说缓存溢出可以执行攻击者预订好的程序，给系统带来巨大的安全风险。虽然我们可以采用各种各样的技术来进行防范，但是道高一尺魔高一丈，比方说采用返回导向编程[6]的堆栈溢出攻击，在出现之后长达十多年里，主流操作系统都毫无防范之力！不过，我们在『读厚』部分能够亲自体验一把漏洞攻击，知己知彼，百战不殆嘛。</p>
<h3 id="很多东西并不像看起来那样简单">很多东西并不像看起来那样简单</h3>
<p>学习算法的时候肯定离不开思考时间复杂度和空间复杂度，但 O(n3) 真的很糟糕，O(1) 真的就很好吗？虽然在单纯的算法分析中是如此，但是在计算机系统中，算法只是一小部分。假设一个 O(1) 的算法会导致死锁，虽然看起来比 O(n3) 的算法好得多，然而真正执行起来，可能就是无尽的等待了。</p>
<p>程序执行并不是一锤子买卖，从算法到数据表示再到程序流程，从内存到缓存再到运算器。不理解计算机系统本身，不理解程序是如何编译执行，又怎么能够写出好程序呢？</p>
<p>前面提到冯诺依曼架构带来了溢出的问题，二进制和十进制的差异也是的计算机中的数学，和理论上的数学有细微的差异。不要小看这点差异，如果因为忽视了它们而采用了错误的假定，基本是不可能得出准确的结果的，不过话说回来，很多时候计算机中也没有什么『准确的结果』，更多的是『可以表示的结果』。</p>
<p>我们知道，在纸面上看 (x+1)2≥0 是一定的，但是在计算机中就不一定了，比方说：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span></span><br><span>$ lldb</span><br><span>(lldb) <span>print</span> (233333 + 1) * (233333 + 1)</span><br><span>(int) <span>$0</span> = -1389819292</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>简单来说，溢出了，就成了负数。但是因为浮点数的表示方法和整数不同，并不会出现因为溢出而变成负数的问题。</p>
<p>那为啥我们不干脆都用浮点数？因为浮点数也有自己的问题，比方说 (x+y)+z=x+(y+z) 在浮点数运算就不一定了：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></pre></td><td><pre><span></span><br><span>$ lldb</span><br><span>(lldb) <span>print</span> (1e20 + -1e20) + 3.14</span><br><span>(double) <span>$0</span> = 3.1400000000000001</span><br><span>(lldb) <span>print</span> 1e20 + (-1e20 + 3.14)</span><br><span>(double) <span>$1</span> = 0</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>交换一下顺序结果就完全不同了，这又是为什么？因为浮点数的表示方法虽然可以避免溢出（极端情况还是会），但会损失部分精度。</p>
<p>如果一定要在计算机系统中找一个关键词，在我看来一定是『权衡』，在之后的学习过程中，我们会常常看到因为实际与理论的差异不得不做出的妥协，而真正的智慧结晶，则是在妥协的同时找到最接近完美的权衡，可谓『带着镣铐跳舞』。</p>
<h3 id="内存里多的是我们不知道的事">内存里多的是我们不知道的事</h3>
<p>很多著名网站都是由于内存错误『引发』的，比方说 stackoverflow 和 segmentfault。虽然现代编程语言大多采用了比较完善的内存保护的机制，但是从 C 时代流传下来的这些错误名称则随着时间推移成为了经典，颇有『为人不识 XX 兰，阅尽 XX 也枉然』的既视感。</p>
<p>的确，无论是 C 或者 C++ 都没有提供任何内存保护机制，再加上强大且危险的指针，出现溢出或者段错误实在是家常便饭。这类问题的问题在于，很难确定是程序本身的问题，还是编译器或者系统的问题。好吧，虽然大部分时候是程序的问题，即便如此也很难发现根源，毕竟我们的思考方式没办法做到和计算机一样。</p>
<p>我们可见的内存并不是物理内存，而是一个非物理的抽象概念。不但需要考虑边界，还得负责空间的分配和管理。假如程序的问题出在动态内存分配上，想要找出来就不那么简单的，毕竟 RAM 中的 R 意思是随机(Random)，要在随机中找确定，难免要花大把的时间。</p>
<p>更『可怕』的是，要想真正理解计算机系统中的诸多概念，得去读机器代码，当然不用读 0 和 1 啦，可是汇编是少不了的。汇编虽然是机器相关的，好在现在 Intel 的 CPU 基本一统江湖，我们不必考虑不同平台的差异。但是在学习的过程中一定能深深感受到，能编写机器无关的代码，是多么幸福的事情。汇编相比高级编程语言更加反直觉，在这里我只能鼓励大家硬着头皮上了。</p>
<h2 id="比特心生">比特心生</h2>
<p>扯了这么多，我们还是回到这一讲的主要内容 —— 比特(bit)。研究问题有两种方法，一种是自顶向下，另一种是自底向上。对于设计来说，很多时候是自顶向下的，从一个整体想法出发，然后慢慢细化；而在学习化学的时候，往往是自底向上的，比方说先去了解组成元素的基本粒子，然后在这些粒子的基础上进行更加抽象的研究。从这个角度看，学习计算机系统，自底向上可能是一个好的方向。</p>
<p>这一节的标题源自于比特新声[7]这一档播音节目，改了俩字儿，意在强调比特的重要性。</p>
<p>在计算机中，我们看到的一切，归根到底，都是比特，每个比特不是 0 就是 1。计算机就是通过对比特进行不同方式的编码和描述，来完成执行不同的任务。那么问题来了，为什么是比特而不是其他呢？这就要从模拟电路讲起，一言以蔽之就是，比特这种描述方式很好存储，并且在有噪声或者传输不那么准确的情况下，也能保持比较高的可靠度（电压值有一定的容错范围）。</p>
<p>在这样的物理基础上，计算机就是一个二进制系统，我们通过下面这个表格来把二进制、十进制和十六进制一一对应起来，这三种数字表示形式在今后的学习过程中会反复出现，可以把这个表格当做九九乘法表来看：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>十进制</th>
<th>二进制</th>
<th>十六进制</th>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>A</td>
<td>10</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>B</td>
<td>11</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>C</td>
<td>12</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>D</td>
<td>13</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>E</td>
<td>14</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>F</td>
<td>15</td>
<td>1111</td>
</tr>
</tbody>
</table>
<p>正如加减乘除，关于比特的基本逻辑运算也有四种，可以看做是布尔代数[8]的子集。对于 0 和 1 来说，是这样的：</p>
<ul>
<li>与 And：<code>A=1</code> 且 <code>B=1</code> 时，<code>A&amp;B = 1</code></li>
<li>或 Or：<code>A=1</code> 或 <code>B=1</code> 时，<code>A|B = 1</code></li>
<li>非 Not：<code>A=1</code> 时，<code>~A=0</code>；<code>A=0</code> 时，<code>~A=1</code></li>
<li>异或 Exclusive-Or(Xor)：<code>A=1</code> 或 <code>B=1</code> 时，<code>A^B = 1</code>；<code>A=1</code> 且 <code>B=1</code> 时，<code>A^B = 0</code></li>
</ul>
<p>对应与集合运算则是交集、并集、差集和补集，假设集合 A 是 <code>&#123;0, 3, 5, 6&#125;</code>，集合 B 是 <code>&#123;0, 2, 4, 6&#125;</code>，全集为 <code>&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>（感谢网友 Sangrita. 指出）那么：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>&#123;0, 6&#125;</code></li>
<li><code>|</code> 并集 Union <code>&#123;0, 2, 3, 4, 5, 6&#125;</code></li>
<li><code>^</code> 差集 Symmetric difference <code>&#123;2, 3, 4, 5&#125;</code></li>
<li><code>~</code> 补集 Complement <code>&#123;1, 3, 5, 7&#125;</code></li>
</ul>
<p>有了这些知识，我们就可以来具体看看不同类型的数据在计算机中是如何存储和进行运算的了。</p>
<h2 id="整型-Integer">整型 Integer</h2>
<p>C 语言之所以效率高，很大程度上是因为抽象程度较低，很多关键字和计算机系统中的概念是一一对应的。比方说 <code>signed</code> 和 <code>unsigned</code>，就表示有符号数和无符号数。假设字长(word size)为 <code>w</code>，那么二进制向十进制的转换分别是：</p>
<ul>
<li>无符号数：B2U(X)=∑i=0w−1xi·2i</li>
<li>有符号数： B2T(X)=−xw−1·2w−1+∑i=0w−2xi·2i</li>
</ul>
<p>有符号数和无符号数的区别主要在于有没有最高位的符号位，以及由此带来的计算方式的不同。符号位中，0 表示非负数，1 表示负数。具体的表示方法如下</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>15213</td>
<td>3B 6D</td>
<td>00111011 01101101</td>
</tr>
<tr>
<td>-15213</td>
<td>C4 93</td>
<td>11000100 10010011</td>
</tr>
</tbody>
</table>
<p>对于二进制数字来说，还有两种常用操作：左移和右移。左移比较简单，在右边补 0 即可。右移的话有两种类型，一种是逻辑右移（左边补 0），另一种是算术右移（左边补符号位）。为什么会有这两种，因为对应无符号数和有符号数的运算，有符号数的最高位（最左边）是符号位在负数的时候需要进行算术右移</p>
<h3 id="整型表示的特点">整型表示的特点</h3>
<p>接下来我们看看这种表示形式的特点，以及溢出的集中情况，假设字长为 <code>w</code>，定义如下的常量：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = 2w−1 即 111…1</li>
<li>TMin = −2w−1 即 100…0</li>
<li>TMax = 2w−1−1 即 011…1</li>
<li>Minus 1 即 111…1</li>
</ul>
<p>这里的 U 表示无符号数，T 表示补码(Two’s Complement)，对于字长为 16 的情况来说，我们有：</p>
<table>
<thead>
<tr>
<th>\</th>
<th>Decimal</th>
<th>Hex</th>
<th>Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td>UMax</td>
<td>65535</td>
<td>FF FF</td>
<td>11111111 11111111</td>
</tr>
<tr>
<td>TMax</td>
<td>32767</td>
<td>7F FF</td>
<td>01111111 11111111</td>
</tr>
<tr>
<td>TMin</td>
<td>-32768</td>
<td>80 00</td>
<td>10000000 00000000</td>
</tr>
<tr>
<td>-1</td>
<td>-1</td>
<td>FF FF</td>
<td>11111111 11111111</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>00 00</td>
<td>00000000 00000000</td>
</tr>
</tbody>
</table>
<p>对于不同的 word size，数值也会有很大的变化</p>
<table>
<thead>
<tr>
<th>w</th>
<th>8</th>
<th>16</th>
<th>32</th>
<th>64</th>
</tr>
</thead>
<tbody>
<tr>
<td>UMax</td>
<td>255</td>
<td>65,535</td>
<td>4,294,967,295</td>
<td>18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>TMax</td>
<td>127</td>
<td>32,767</td>
<td>2,147,483,647</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>TMin</td>
<td>-128</td>
<td>-32,768</td>
<td>-2,147,483,648</td>
<td>-9223,372,036,854,775,808</td>
</tr>
</tbody>
</table>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>U2B(x)=B2U−1(x)</li>
<li>T2B(x)=B2T−1(x)</li>
</ul>
<h3 id="类型转换">类型转换</h3>
<p>我们在数轴上把有符号数和无符号数画出来的话，就能很清晰的看出相对的关系：</p>
<p><img src="/img/post/csapp/14609257940557.jpg" alt=""></p>
<p>在 C 语言中，如果不加关键字限制，默认的整型是有符号的。如果想要无符号数的话，需要在数字后面加 <code>U</code>，例如下面的代码段</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br></pre></td><td><pre><span><span>int</span> a_signed_number = <span>-15213</span>;</span><br><span><span>unsigned</span> <span>int</span> a_unsigned_number = <span>15213U</span>;</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>在进行有符号和无符号数的互相转换时：</p>
<ul>
<li>具体每一个字节的值不会改变，改变的是计算机解释当前值的方式</li>
<li>如果一个表达式既包含有符号数也包含无符号数，那么会被隐式转换成无符号数进行比较</li>
</ul>
<p>下面用字长 <code>w = 32</code> 为例，来进行说明，注意这里的每个表达式都是成立的，其中 <code>TMin = -2,147,483,648</code>, <code>TMax = 2,147,483,647</code></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>比较对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 == 0U</td>
<td>无符号数</td>
</tr>
<tr>
<td>-1 &lt; 0</td>
<td>有符号数</td>
</tr>
<tr>
<td>-1 &gt; 0U</td>
<td>无符号数</td>
</tr>
<tr>
<td>2147483647 &gt; (-2147483647-1)</td>
<td>有符号数</td>
</tr>
<tr>
<td>2147483647U &lt; (-2147483647-1)</td>
<td>无符号数</td>
</tr>
<tr>
<td>-1 &gt; -2</td>
<td>有符号数</td>
</tr>
<tr>
<td>(unsigned)-1 &gt; -2</td>
<td>无符号数</td>
</tr>
<tr>
<td>2147483647 &lt; 2147483648U</td>
<td>无符号数</td>
</tr>
<tr>
<td>2147483647 &gt; (int)2147483648U</td>
<td>有符号数</td>
</tr>
</tbody>
</table>
<h3 id="类型扩展与截取">类型扩展与截取</h3>
<p>具体需要分情况讨论，如：</p>
<ul>
<li>扩展（例如从 <code>short int</code> 到 <code>int</code>），都可以得到预期的结果
<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
</ul>
</li>
<li>截取（例如 <code>unsigned</code> 到 <code>unsigned short</code>），对于小的数字可以得到预期的结果
<ul>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
</ul>
</li>
</ul>
<p>举个例子</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span><span>short</span> <span>int</span> x = <span>15213</span>;</span><br><span><span>int</span> ix = (<span>int</span>) x;</span><br><span><span>short</span> <span>int</span> y = <span>-15213</span>;</span><br><span><span>int</span> iy = (<span>int</span>) y;</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>C 语言会自动做符号拓展，把小的数据类型转换成大的，如下表所示</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>x=15213</td>
<td>3B 6D</td>
<td>00111011 01101101</td>
</tr>
<tr>
<td>ix=15213</td>
<td>00 00 3B 6D</td>
<td>00000000 00000000 00111011 01101101</td>
</tr>
<tr>
<td>y=-15213</td>
<td>C4 93</td>
<td>11000100 10010011</td>
</tr>
<tr>
<td>iy=-15213</td>
<td>FF FF C4 93</td>
<td>11111111 11111111 11000100 10010011</td>
</tr>
</tbody>
</table>
<h3 id="运算与溢出">运算与溢出</h3>
<p>无论是无符号数还是有符号数，一旦用来表示数值的最高位发生了进位，超出了表达形式或者改变了符号位，就会发生溢出。</p>
<p>对于无符号数加法，如果两个 <code>w</code> 位的数字相加，结果是 <code>w+1</code> 位的话，那么就会丢弃掉最高位，实际上是做了一个 mod 操作（公式为 s=UAddw(u,v)=u+vmod2w）</p>
<p>假设 <code>w=3</code>，那么能够表达的数字范围是 <code>000~111(0~7)</code>（括号内为二进制对应的十进制数值，后同），那么如果一个表达式是 <code>110+111(6+7)</code>，原本应该等于 <code>1101(13)</code>，但是由于 <code>w=3</code>，所以最终的结果是 <code>101(5)</code>，也就是发生了溢出，两个无符号数相加，有可能反而变『小』。</p>
<p>对于有符号的加法(Two’s Complement Addition)，操作过程和无符号加法一样，只是解释的时候会有不同，因此会得到正溢出(positive overflow)和负溢出(negative overflow)两种。正溢出就是数值太大把原来为 0 的符号位修改成了 1，反而成了负数；负溢出是数值太小，把原来为 1 的符号位修改成了 0，反而成了正数。</p>
<p>还是用刚才 <code>w=3</code> 作为例子，能够表达的数字范围是 <code>100~011(-4~3)</code>，如果一个表达式是 <code>011+010(3+2)</code>，理论上应该等于 5，但是相加之后变成了 <code>101(-3)</code>，也就是发生了正溢出。如果一个表达式是 <code>100+101(-4+(-3))</code>，理论上应该等于 -7，但是相加后进位截取变成了 <code>001(1)</code>，也就是发生了负溢出。</p>
<p>对于乘法来说，值的范围会大很多，这里分情况讨论一下，假设两个乘数是 x,y 并且都是 w 位的：</p>
<ul>
<li>无符号数：至多 2w 位
<ul>
<li>范围 0≤x×y≤(2w−1)2=22w−2w+1+1</li>
</ul>
</li>
<li>有符号数，最小的负数：至多 2w - 1 位
<ul>
<li>范围 x×y≥(−2w−1)×(2w−1−1)=−22w−2+2w−1</li>
</ul>
</li>
<li>有符号数，最大的正数：至多 2w 位，只有 (TMinw)2 一种情况
<ul>
<li>范围 x×y≤(−2w−1)2=22w−2</li>
</ul>
</li>
</ul>
<p>如果需要保证精度，就需要用软件来实现了。另外，计算的无符号乘法的时候，会忽略最高的 w 位，相当于 UMultw(u,v)=u·vmod2w</p>
<h2 id="浮点数-Float">浮点数 Float</h2>
<p>浮点数可以用一个统一的公式来表达：</p>
<p>∑k=−jibk×2k</p>
<p>例如</p>
<p>534=101.112,278=10.1112,1716=1.01112</p>
<p>可以看到除以二就相当于右移，并且可以横跨小数点。注意 0.111…2 非常接近于 1，因为</p>
<p>1/2+1/4+1/8+…+1/2i+…→1.0</p>
<p>通常用 1.0−ϵ 来表示这个值。</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 x2k 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：13=0.0101010101[01]…2。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的，具体的原因会在后面详细解释。</p>
<h3 id="IEEE-浮点数标准">IEEE 浮点数标准</h3>
<p>IEEE 的浮点数标准更多是从数值角度来建立的，对于舍入，上溢出和下溢出都有比较统一的处理方法。但与此同时也给硬件优化带来了比较大的困难。因为和平时使用的数制也有一定差异，从理解的角度来看不够直观，但是好在主流的 CPU 都支持浮点数，所以我们不必过多涉及这方面的细节。</p>
<p>在 IEEE 标准中，我们用下面的公式来表达浮点数：</p>
<p>(−1)sM2E</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码时结构如下，这里用单精度、双精度和扩展精度为例：</p>
<p><img src="/img/post/csapp/14609515849125.jpg" alt=""></p>
<p>其中 <code>s</code> 对应着符号位，<code>exp</code> 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），<code>frac</code> 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源。</p>
<p><strong>规范化值(Normalized Values)</strong></p>
<p>在 exp≠000…0 和 exp≠111…1 时，表示的其实都是规范化的值，为什么说是规范化呢？这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解（所以现在不明白也不用担心）</p>
<p>再来回顾一下我们计算浮点数的公式：</p>
<p>v=(−1)sM2E</p>
<p>这里的 E 是一个偏移的值 E=Exp−Bias，其中</p>
<ul>
<li>Exp: 是 exp 编码区域的无符号数值</li>
<li>Bias：值为 2k−1−1 的偏移量，其中 k 是 exp 编码的位数，也就是说
<ul>
<li>单精度：127（Exp: 1…254, E: -126…127）</li>
<li>双精度：1023（Exp: 1…2046, E: -1022…1023）</li>
</ul>
</li>
</ul>
<p>之所以需要采用一个偏移量，是为了保证 exp 编码只需要以无符号数来处理。</p>
<p>而对于 M，一定是以 1 开头的：也就是 M=1.xxx…x2。其中 xxx 的部分就是 frac 的编码部分，当 frac=000.00 的时候值最小（M=1.0），当 frac=111。。。1 的时候值最大（M=2.0−ϵ），也就是说开头的 1 是『免费附送的』，并不需要实际的编码位。</p>
<p>举个例子，<code>float F = 15213.0;</code>，那么</p>
<p>1521310=111011011011012=1.11011011011012×213</p>
<p>于是 frac 部分的值就是小数点后面的数值，而 Exp = E + Bias = 13 + 127 = 140 = 100011002，于是编码出来的浮点数是这样的：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br></pre></td><td><pre><span>0 10001100 11011011011010000000000</span><br><span>s   exp             frac</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p><strong>非规范化值(Denormalized Values)</strong></p>
<p>当 exp=000…0 的时候，值是非规范化的，意思是，虽然实数轴上原来连续的值会被规范到有限的定值上，但是并些定值之间的间距也是一样的，具体可以通过后面给出的例子来理解（所以现在不明白也不用担心）</p>
<p>v=(−1)sM2E</p>
<p>和前面不同的是</p>
<p>E=1−Bias</p>
<p>而且 M=0.xxx…x2，不是以 1 开头了。</p>
<p>当 exp=000…0 且 frac = 000…0 时，表示 0，而且因为符号位的缘故，实际上是有 +0 和 -0 两种的。而在 exp=000…0 且 frac≠000…0 时，数值是接近 0 的，并且间距是一致的</p>
<p><strong>特殊值</strong></p>
<p>还有一种特殊情况，就是 exp=111…1 时，表示一些特殊值。</p>
<p>当 exp=111…1 且 frac = 000…0 时，表示 ∞，而且因为符号位的缘故，实际上是有 +∞ 和 −∞ 两种的。那些会溢出的操作就会用这个来表示，比如 1.0/0.0=−1.0/0.0=+∞,1.0/−0.0=−∞</p>
<p>而在 exp=111…1 且 frac≠000…0 时，我们认为这不是一个数值（Not-a-Number，NaN），用来表示那些没办法确定的值，比如 sqrt(−1),∞−∞,∞×0</p>
<h3 id="实例学习">实例学习</h3>
<p>可能通过文字描述还是不够清晰，我们来看看上面各种情况对应到数轴中是怎么样的：</p>
<p><img src="/img/post/csapp/14609523456310.jpg" alt=""></p>
<p>接下来举一个实际的例子，我们采用 1 位符号位，4 位 exp 位，3 位 frac 位，因此对应的 bias 为 7。回顾一下几个重要公式：</p>
<p>v=(−1)sM2E</p>
<p>对于规范化数：E=Exp−Bias；对于非规范数：E=1−Bias，正数部分的数值为</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></pre></td><td><pre><span>    s exp  frac   E   值</span><br><span>------------------------------------------------------------------</span><br><span>    0 0000 000   -6   0   </span><br><span>    0 0000 001   -6   1/8 * 1/64 = 1/512 </span><br><span>    0 0000 010   -6   2/8 * 1/64 = 2/512 </span><br><span>    ...</span><br><span>    0 0000 110   -6   6/8 * 1/64 = 6/512</span><br><span>    0 0000 111   -6   7/8 * 1/64 = 7/512 </span><br><span>------------------------------------------------------------------</span><br><span>    0 0001 000   -6   8/8 * 1/64 = 8/512 </span><br><span>    0 0001 001   -6   9/8 * 1/64 = 9/512</span><br><span>    ...</span><br><span>    0 0110 110   -1   14/8 * 1/2 = 14/16</span><br><span>    0 0110 111   -1   15/8 * 1/2 = 15/16 </span><br><span>    0 0111 000    0   8/8 * 1 = 1</span><br><span>    0 0111 001    0   9/8 * 1 = 9/8      </span><br><span>    0 0111 010    0   10/8 * 1 = 10/8</span><br><span>    ...</span><br><span>    0 1110 110    7   14/8 * 128 = 224</span><br><span>    0 1110 111    7   15/8 * 128 = 240   </span><br><span>------------------------------------------------------------------</span><br><span>    0 1111 000   n/a  无穷               </span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>观察上表，我们可以发现如下一些比较有意思的规律：</p>
<ul>
<li>在 <code>exp=0000</code> 时，也就是非规范化的情况，间距是一致的，都是 1/8</li>
<li>因为位数的限制，从零到一之间的数字只能以 1/8 为最小单位来表示，且相邻数字间间距一样</li>
<li>在规范化的部分，可以发现由于 exp 部分的不同，所以相邻数字间的间隔也是不同的，比方说最接近 1 的数字是 15/16 和 9/8，分别相差 1/16 和 1/8，这也是由于 IEEE 浮点数表示法的公式决定的</li>
</ul>
<h3 id="舍入">舍入</h3>
<p>对于浮点数的加法和乘法来说，我们可以先计算出准确值，然后转换到合适的精度。在这个过程中，既可能会溢出，也可能需要舍入来满足 frac 的精度。</p>
<p>在二进制中，我们舍入到最近的偶数，即如果出现在中间的情况，舍入之后最右边的值要是偶数，对于十进制数，例子如下：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></pre></td><td><pre><span>  原数值       舍入结果    原因</span><br><span>2.8949999      2.89    不到一半，正常四舍五入</span><br><span>2.8950001      2.90    超过一般，正常四舍五入</span><br><span>2.8950000      2.90    刚好在一半时，保证最后一位是偶数，所以向上舍入</span><br><span>2.8850000      2.88    刚好在一半时，保证最后一位是偶数，所以向下舍入</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>对于二进制数也是类似的</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></pre></td><td><pre><span>  十进制    二进制     舍入结果  十进制    原因</span><br><span>2 又 3/32  10.00011   10.00     2      不到一半，正常四舍五入</span><br><span>2 又 3/16  10.00110   10.01  2 又 1/4   超过一般，正常四舍五入</span><br><span>2 又 7/8   10.11100   11.00     3      刚好在一半时，保证最后一位是偶数，所以向上舍入</span><br><span>2 又 5/8   10.10100   10.10  2 又 1/2   刚好在一半时，保证最后一位是偶数，所以向下舍入</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<h3 id="浮点数加法">浮点数加法</h3>
<p>(−1)s1M12E1+(−1)s2M22E2</p>
<p>这里假设 E1&gt;E2，结果是 (−1)sM2E ，其中 s=s1∧s2,M=M1+M2,E=E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>(3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 a≥b→a+c≥b+c</li>
</ul>
<h3 id="浮点数乘法">浮点数乘法</h3>
<p>(−1)s1M12E1×(−1)s2M22E2</p>
<p>结果是 (−1)sM2E，其中 s=s1∧s2,M=M1×M2,E=E1+E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 a≥b→a×c≥a×b</li>
</ul>
<h2 id="数据在内存中的形式">数据在内存中的形式</h2>
<p>后续章节会有关于内存的详细介绍，这里我们只要知道不同数据类型所占据的字节数，以及大端-小端规则即可。</p>
<p>操作系统会给每个进程提供私有的虚拟内存地址空间，一个进程可以访问自己的数据，但是不能访问别人的数据。在虚拟内存中地址是连续的，对应物理内存则不一定，根据字长的不同，有不同的间隔，如下图所示</p>
<p><img src="/img/post/csapp/14609333219815.jpg" alt=""></p>
<p>然后我们来看看常见数据类型所需要的字节数：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>32 位</th>
<th>64 位</th>
<th>x86-64</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>long double</td>
<td>-</td>
<td>-</td>
<td>10/16</td>
</tr>
<tr>
<td>指针</td>
<td>4</td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>数据具体的排列也有两种方式：大端(Big Endian)与小端(Little Endian)，区别在于高位地址的位置。Internet 数据采用大端规则，而我们常见的 x86 或 ARM 处理器都采用小端规则。</p>
<p>举个例子，假如变量 <code>x</code> 是 4 字节，值为 <code>0x01234567</code>。用 <code>&amp;x</code> 索引的地址是 <code>0x100</code>，那么大端和小端的表示形式是</p>
<p><img src="/img/post/csapp/14609496617886.jpg" alt=""></p>
<p>如何检查数据的表示呢，可以用下面的代码</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td><td><pre><span><span>typedef</span> <span>unsigned</span> <span>char</span> *pointer;</span><br><span></span><br><span><span><span>void</span> <span>show_bytes</span><span>(pointer start, <span>size_t</span> len)</span> </span>{</span><br><span><span>size_t</span> i;</span><br><span><span>for</span> (i = <span>0</span>; i &lt; len; i++)</span><br><span><span>printf</span>(<span>"%p\t0x%.2x\n"</span>, start+i, start[i]);</span><br><span><span>printf</span>(<span>"\n"</span>);</span><br><span>}</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>这里 <code>%p</code> 用来输出指针，<code>%x</code> 用来输出 16 进制数据。执行可用：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>int</span> a = <span>15213</span>;</span><br><span><span>printf</span>(<span>"int a = 15213;\n"</span>);</span><br><span>show_bytes((pointer) &amp;a, <span>sizeof</span>(<span>int</span>));</span><br></pre></td></tr></tbody></table>
<p>复制</p>
<p>在我的电脑上，测试如下：</p>
<p><img src="/img/post/csapp/csapp12.jpg" alt="csapp12"></p>
<h2 id="总结">总结</h2>
<p>这一讲，我们从编程的常见误区开始，简要介绍了计算机架构。并从最基本的元素——比特开始，逐步说明了整型和浮点数这两个非常重要的基础数据类型。这之中涉及了类型转换、扩展与截取、运算与溢出。浮点数因为 IEEE 标准与常识的差异，通过具体的例子进行了讲解，最后引出了舍入的概念。</p>
<p>需要注意的是，这部分内容知识点比较零碎，需要通过具体例子去理解。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10779604/">图灵的秘密</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC">约翰·冯·诺伊曼</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EDVAC%E5%A0%B1%E5%91%8A%E6%9B%B8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%8D%89%E6%A1%88">101 页报告</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84">哈佛架构</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B">返回导向编程</a></li>
<li><a target="_blank" rel="noopener" href="http://www.bitvoice.xyz/">比特新声</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0">布尔代数</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://wdxtub.com/work/">小土刀</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://wdxtub.com/work/">https://wdxtub.com/work/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归原作者所有，如有转载，请注明来自原作者</span></div></div><div class="post_share"><div class="social-share" data-image="/img/sea.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/876388a3.html" title="CSAPP-【三四五】机器指令与程序优化-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSAPP-【三四五】机器指令与程序优化-补充阅读与总结【转载】</div></div></a></div><div class="next-post pull-right"><a href="/posts/49f86f66.html" title="CSAPP-深入理解计算机系统-动机"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSAPP-深入理解计算机系统-动机</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b1fb9525.html" title="CSAPP-【第十章】系统级IO-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-27</div><div class="title">CSAPP-【第十章】系统级IO-补充阅读与总结【转载】</div></div></a></div><div><a href="/posts/882cf7d3.html" title="CSAPP-【第七章】链接-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-09</div><div class="title">CSAPP-【第七章】链接-补充阅读与总结【转载】</div></div></a></div><div><a href="/posts/525342f9.html" title="CSAPP-【第九章】虚拟内存-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">CSAPP-【第九章】虚拟内存-补充阅读与总结【转载】</div></div></a></div><div><a href="/posts/618b80aa.html" title="CSAPP-【第六章】存储器层次结构-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-02</div><div class="title">CSAPP-【第六章】存储器层次结构-补充阅读与总结【转载】</div></div></a></div><div><a href="/posts/f41e98fa.html" title="CSAPP-【第十一章】网络-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="title">CSAPP-【第十一章】网络-补充阅读与总结【转载】</div></div></a></div><div><a href="/posts/6bc76c46.html" title="CSAPP-【第八章】异常流控制-补充阅读与总结【转载】"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-17</div><div class="title">CSAPP-【第八章】异常流控制-补充阅读与总结【转载】</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/m.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MrMatrix</div><div class="author-info__description">To be a better man.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">188</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">63</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.zhihu.com/people/MrMatrix"><i></i><span>知乎</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个博客是为了记录自己在科研、工作的过程中捕获到的有价值的课程与书籍，是面向我自己搭建的查漏补缺的备忘录和记事本</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D"><span class="toc-number">2.</span> <span class="toc-text">编程迷思</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">计算机不只是执行程序的机器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E5%A4%9A%E4%B8%9C%E8%A5%BF%E5%B9%B6%E4%B8%8D%E5%83%8F%E7%9C%8B%E8%B5%B7%E6%9D%A5%E9%82%A3%E6%A0%B7%E7%AE%80%E5%8D%95"><span class="toc-number">2.2.</span> <span class="toc-text">很多东西并不像看起来那样简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8C%E5%A4%9A%E7%9A%84%E6%98%AF%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B"><span class="toc-number">2.3.</span> <span class="toc-text">内存里多的是我们不知道的事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%BF%83%E7%94%9F"><span class="toc-number">3.</span> <span class="toc-text">比特心生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B-Integer"><span class="toc-number">4.</span> <span class="toc-text">整型 Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">整型表示的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95%E4%B8%8E%E6%88%AA%E5%8F%96"><span class="toc-number">4.3.</span> <span class="toc-text">类型扩展与截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E4%B8%8E%E6%BA%A2%E5%87%BA"><span class="toc-number">4.4.</span> <span class="toc-text">运算与溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0-Float"><span class="toc-number">5.</span> <span class="toc-text">浮点数 Float</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86"><span class="toc-number">5.1.</span> <span class="toc-text">IEEE 浮点数标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.2.</span> <span class="toc-text">实例学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%8D%E5%85%A5"><span class="toc-number">5.3.</span> <span class="toc-text">舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">浮点数加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">浮点数乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">数据在内存中的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">8.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6382afc7.html" title="观陶哲轩演讲-AI与数学-后有感">观陶哲轩演讲-AI与数学-后有感</a><time datetime="2024-08-29T16:00:00.000Z" title="发表于 2024-08-30 00:00:00">2024-08-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b9a84247.html" title="国科大-随机过程-写在后面">国科大-随机过程-写在后面</a><time datetime="2024-01-28T16:00:00.000Z" title="发表于 2024-01-29 00:00:00">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4309bd24.html" title="国科大-随机过程-连续时间马尔可夫链">国科大-随机过程-连续时间马尔可夫链</a><time datetime="2024-01-27T16:00:00.000Z" title="发表于 2024-01-28 00:00:00">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b497123d.html" title="国科大-随机过程-马尔可夫链的转移概率与极限行为">国科大-随机过程-马尔可夫链的转移概率与极限行为</a><time datetime="2024-01-20T16:00:00.000Z" title="发表于 2024-01-21 00:00:00">2024-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8d52a7e7.html" title="国科大-随机过程-马尔可夫链中的常反性及其相关概念">国科大-随机过程-马尔可夫链中的常反性及其相关概念</a><time datetime="2024-01-15T16:00:00.000Z" title="发表于 2024-01-16 00:00:00">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sea.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By MrMatrix</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a href="http://www.beian.gov.cn" target="_blank"><img class="lozad" data-src="/img/beian.png" onerror="onerror=null;src='/img/beian.png'" style="padding:0px;vertical-align: text-bottom;"/><span>浙ICP备2024121111号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams'
        },
        chtml: {
          scale: 1.1
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div><script src="/js/category.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":false},"react":{"opacity":0.85},"log":false});</script></body></html>