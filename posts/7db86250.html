<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PMP-多边形网格处理-变形 | MM's Journal of Technology</title><meta name="author" content="MrMatrix"><meta name="copyright" content="MrMatrix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一个三角形网格的 变形(Deformation) 算法应该满足下面两个基本条件  能够隐藏于交互界面之后 效率足够高以满足交互需求  将曲面S变形为曲面S’的过程可以描述为：给定一个 位移函数(Displacement Function) ，该函数输入曲面上的点p∈S，给出一个 位移向量(Displacement Vector) —— d(p) ，并通过以下方式将曲面S映射为变形后的曲面S′  对">
<meta property="og:type" content="article">
<meta property="og:title" content="PMP-多边形网格处理-变形">
<meta property="og:url" content="http://mmwiki.cn/posts/7db86250.html">
<meta property="og:site_name" content="MM&#39;s Journal of Technology">
<meta property="og:description" content="一个三角形网格的 变形(Deformation) 算法应该满足下面两个基本条件  能够隐藏于交互界面之后 效率足够高以满足交互需求  将曲面S变形为曲面S’的过程可以描述为：给定一个 位移函数(Displacement Function) ，该函数输入曲面上的点p∈S，给出一个 位移向量(Displacement Vector) —— d(p) ，并通过以下方式将曲面S映射为变形后的曲面S′  对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mmwiki.cn/img/sea.jpg">
<meta property="article:published_time" content="2022-01-14T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-13T01:55:51.217Z">
<meta property="article:author" content="MrMatrix">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="数字几何处理">
<meta property="article:tag" content="多边形网格处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mmwiki.cn/img/sea.jpg"><link rel="shortcut icon" href="/img/m.png"><link rel="canonical" href="http://mmwiki.cn/posts/7db86250.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PMP-多边形网格处理-变形',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-13 09:55:51'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/zhihu.css" media="defer" onload="this.media='all'"><!-- 其他 head 内容--><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/m.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">76</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/sea.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MM's Journal of Technology"><img class="site-icon" src="/img/m.png" alt="Logo"/><span class="site-name">MM's Journal of Technology</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PMP-多边形网格处理-变形</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-01-14T16:00:00.000Z" title="发表于 2022-01-15 00:00:00">2022-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/%F0%9F%93%97-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">📗-多边形网格处理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">多边形网格处理</a></div></div><article class="post-content" id="article-container"><p>一个三角形网格的 <strong>变形(Deformation)</strong> 算法应该满足下面两个基本条件</p>
<ol>
<li>能够隐藏于交互界面之后</li>
<li>效率足够高以满足交互需求</li>
</ol>
<p>将曲面S变形为曲面S’的过程可以描述为：给定一个 <strong>位移函数(Displacement Function)</strong> ，该函数输入曲面上的点p∈S，给出一个 <strong>位移向量(Displacement Vector)</strong> —— d(p) ，并通过以下方式将曲面S映射为变形后的曲面S′</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-0.png" alt=""></p>
<p>对于离散的三角形网格，位移函数d是分段线性(Piecewise Linear)的，即对于 pi∈S</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-1.png" alt=""></p>
<p>为了人为的控制变形的过程，我们常常会在网格上指定一些控制点pi∈S⊂H，然后固定网格的一部分F⊂S，对于这些点，其位移函数可以描述为</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-2.png" alt=""></p>
<p>下图中我们对一个正方形的曲面S进行变形，固定曲面S浅蓝色的部分F，然后选取黄色部分H的顶点作为控制顶，将其向上拉动。可以看到经过变形后，没有被固定的部分(R，即深蓝色部分)的顶点的位置发生了相应的变换。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-3.png" alt=""></p>
<p>一个主要的问题就是如何选取合适的位移函数di，使得变形的结果符合需求。这里将会讨论两大类变形的方法</p>
<ol>
<li>
<p><strong>基于曲面的变形(Surface-Based Deformations)</strong>：位移函数d是从曲面S到三位空间的映射，即计算时在三角形网格上进行的。这类方法能够有很高的控制度，能够对每一个顶点都加以控制，但是其鲁棒性不好，运行效率往往取决网格的的复杂度和质量。</p>
</li>
<li>
<p><strong>空间变形(Space Deformations)</strong>：位移函数d是从三维空间到三位空间的映射，即对曲面S的变形是隐式的。因为计算不依赖于三角形网格曲面S，所以其不受网格复杂度和质量的影响。</p>
</li>
</ol>
<p>这里讨论的大部分方法都是线性的方法，通常只需要解线性方程，即最小化二次能量能量(Quadratic Deformation Energy)。使用线性系统的优点在于求解的效率高，缺点是有些时候得到的结果是不符合直观的。非线性的方法通过最小化更为精确的变形能量，能够达到更好的效果，但是求解效率确不高。</p>
<h2 id="Transformation-Propagation">Transformation Propagation</h2>
<p>一个常用且简单的方法是将对控制点的变换传播到整个变形区域上。在指定好控制点H和变形区域R后，控制点由用户控制发生变换T，然后将变换T插值传播至变形区域R上，使得从固定区域F至变换后控制点所在的区域H′的变化是平滑的。</p>
<p>两者间的插值混合可以由一个标量场s进行控制</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-4.png" alt=""></p>
<p>s=1代表顶点处于控制区域H(区域内的顶点被完全变换)，s=0代表顶点处于固定区域F(区域内的顶点不发生变换)，而位于变换区域R内的顶点的s值则由顶点到区域F和区域H的距离决定</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-5.png" alt=""></p>
<p>距离既可以是测地线距离也可是欧氏距离，前者计算更复杂但是结果的效果更好。</p>
<p>另外标量场s也能够是曲面S上的调和场(无源无旋)，即其满足拉普拉斯方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-6.png" alt=""></p>
<p>对于区域F和H我们加以狄利特雷限制(Dirichlet Constraint)，然后解下列线性拉普拉斯方程即可得到标量场s 。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-7.png" alt=""></p>
<p>虽然此法性能逊于前者，但是能够保证结果足够光滑，而前者基于距离的方法只能保证C1连续。</p>
<p>标量场s还能够进行进一步的调整以提供更多的控制和灵活度。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-8.png" alt=""></p>
<p>得到标量场后，对每一个顶点按以下方法进行插值运算，即可得到变形后顶点的位置。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-9.png" alt=""></p>
<p>不过此法存在一个问题，得到结果并不是几何上最直观的结果，还需要对控制区域H内的顶点的位移函数d进行平滑处理，或者使用最小化某些基于物理量的变形能量的方法。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-10.png" alt=""></p>
<h4 id="原模型-左-；使用插值法计算结果-中-；理想的结果-右">原模型(左)；使用插值法计算结果(中)；理想的结果(右)</h4>
<h2 id="Shell-Based-Deformation">Shell-Based Deformation</h2>
<p>为了得到更直观准确的结果，位移函数d可以通过最小化基于物理的变形能量的方法得到。我们间曲面S看作是能够 <strong>拉伸(Stretching)</strong> 或者 <strong>弯折(Bending)</strong> 的物理材质(皮肤、布料等)，然后使用能量函数来描述拉伸和弯折的程度。</p>
<p>设参数曲面S和S’，曲面由方程p:Ω→R3、p′:Ω→R3给出，且位移函数被定义为 d:Ω→R3。<strong>第一基本型</strong> 和 <strong>第二基本型</strong> 能够被用来衡量曲面的内在几何量(如长度、面积和曲率等)。当曲面S被变形为S′时，其基本型由Ⅰ、Ⅱ变为了Ⅰ′、Ⅱ′，它们的差可以用来描述拉伸和弯折(原文中称这种能量为Elastic Thin Shell Energy)</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-11.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-12.png" alt=""></p>
<p>刚度参数(Stiffness Parameters)ks和kb被用来控制曲面对拉伸和弯折变换的抵抗程度。在实际应用时只需要在变形的区域最小化上述能量即可。</p>
<p>但是上式由于是非线性的，计算量较大，无法应用的到交互式的程序中。所以通常将基本型简化为位移函数d的偏导数(位置之差)，得到下树的Thin Shell Energy</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-13.png" alt=""></p>
<p>其中</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-14.png" alt=""></p>
<p>这个函数和前面介绍平面平滑算法里Fairing方法中衡量曲面面积和曲率的能量的函数相类似。区别在于这里我们使用平移量d而不是位置p且最小化的是面积和曲率的 <strong>变换程度</strong> ，即我们最小化曲面的拉伸和弯折。</p>
<p>下图中，我们固定灰色区域，抬升黄色区域，并且最小化Thin Shell Energy。该能量包含拉伸和弯折两个部分，左图展示了纯拉伸的情况(ks=1,kb=0)，中图展示了纯弯折的情况(ks=0,kb=1)，右图展示了两者混合的情况(ks=1,kb=10)。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-15.png" alt=""></p>
<p>应用曲面平滑算法里Fairing方法中提到求最小化的方法，得到能量函数对应的欧拉拉格朗日方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-16.png" alt=""></p>
<p>为了最小化能量，需要解上述的偏微分方程(PDE)，根据第三章中介绍的方法，将上式子写成离散形式，其中</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-17.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-18.png" alt=""></p>
<p>则上述偏微分方程(PDE)可以被离散为下面逐顶点形式</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-19.png" alt=""></p>
<p>其中变换区域R内自由顶点的位移函数d1,…,dn是未知的(方程左侧 x项)，区域H和区域F中位移函数是已知的(方程右侧b项)。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-20.png" alt=""></p>
<p>L为拉普拉斯矩阵，x和b都是n行3列的矩阵。</p>
<p>最小化得到结果是C1连续的，在三角形网格中C1连续只由区域F和H中First-Two-Rings顶点定义，在最小化的时候不用考虑F和H区域上其它的顶点。</p>
<p>在交互的过程中会控制区域H内的顶点进行操作，使得矩阵方程的右侧的b项不断发生变换，这个情况有更加高效的算法。通过变换限制为仿射变换，也能够将某些计算提前进行预计算以提高效率。</p>
<p>与Transformation Propagation方法相比，此法由于需要每一帧解一个线性方程，计算量相对较大，但是仍然是可交互的。由于此法基于物理法则，故其效果相对较好。</p>
<h2 id="Multi-Scale-Deformation">Multi-Scale Deformation</h2>
<p>前文的Shell-Based Deformation方法并不能够正确地处理小尺度的细节。由于对局部细节的旋转变换并不是线性的，所以不能够完全的使用线性的方法对其进行建模。一个更好的方法是使用后面即将介绍的多尺度变形的方法。</p>
<p>下图中，我们抬升正方形曲面的右侧，左二图展示了使用前文中的线性方法得到的结果，发现其细节并没有被正确的还原。使用Multi-Scale Deformation方法得到结果(左三图)虽然仍然有变形，但是已经和理想的情况(左四图)非常接近了。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-21.png" alt=""></p>
<p>Multi-Scale Deformation的主要思想是使用在曲面平滑算法中提到的分解的方法将曲面分解为高频和低频两个部分。低频部分即是曲面大致的外形，而高频部分则代表小尺度的细节。我们的目标是对低频部分进行变形并保持高频部分的细节。</p>
<p>这个过程在2维情况下如下图所示，虚线部分表示了曲线的低频部分，我们将这条虚线进行变形并添加上高频细节，最终得到了理想的形变结果。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-22.png" alt=""></p>
<p>在三维的情况下，首先通过移除高频部分计算出曲面S的低频形式B(原模型的光滑简化形式)，在B上模型的细节D被移除。将B形变得到B′，通过B′和D我们能够重建出最终的变形后的曲面S′。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-23.png" alt=""></p>
<p>上图中我们只对原模型进行了一次分解，同样地也可以对B再一次进行分解，以达到多吃变形的目的。</p>
<p>可以看到Multi-Scale Deformation主要包含下面三个操作</p>
<ol>
<li>分解(Decomposition)</li>
<li>变形(Deformation)</li>
<li>重建(Reconstruction)</li>
</ol>
<p>其中分解可以使用到第四章提到的网格光滑算法，变形可以使用前文提到的算法。没有提到的就是如何提取细节D并进行相应的重建。</p>
<h3 id="位移向量-Displacement-Vectors">位移向量(Displacement Vectors)</h3>
<p>最直接的表示方法就是使用一个向量函数h:B→R3，函数h(p)表示光滑曲面B上每一个顶点都对应着一个三维向量。由于S和B拥有相同的连接性，所以位移向量</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-24.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-25.png" alt=""></p>
<p>其中b∈B,pi∈S。</p>
<p>使用全局坐标系取表示位移向量得到结果如下图左图所示，正确的方法是使用局部的基向量去表示位移向量(下图右图)。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-26.png" alt=""></p>
<p>因此在存储hi时，需要使用曲面B上每个顶点的局部标价下的坐标而不是全局坐标。我们一般取法向量ni和另外两个向量ti,1和ti,2作为一组正交基</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-27.png" alt=""></p>
<p>基向量在从B变形到B′的过程中会发生相应的旋转，最终我们根据B′的基向量以及位移向量在B中局部坐标基下的坐标可以得到S′上每一个顶点的坐标</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-28.png" alt=""></p>
<p>法向量ni在每一个顶点上都是有定义的，剩下的只需要按照统一的标准取另外两个轴ti,1和ti,2即可。</p>
<h3 id="法向量位移-Normal-Displacements">法向量位移(Normal Displacements)</h3>
<p>当位移向量过长的时候会导致结果不稳定，特别是在进行弯折(Bending)变形的时候，因此位移向量应该越短越好。因此，我们想到不再去寻找B上pi的对应顶点bi，而是去寻找B上距离p最近的顶点。</p>
<p>这种思想就是所谓的法向量位移，即</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-29.png" alt=""></p>
<p>因为在上一节中hi通常是不与法向量平行的，因此法向量位移方法需要对S和B上的顶点进行重新采样，从bi∈B上发射一条与法向量平行的射线以找到其在S上对应的顶点pi，而重采样则会导致Alias Artifacts(走样/假频)现象的出现。</p>
<p>为了改进上面的方法，我们换一个方向。对于点pi∈S，我们寻找一个点bi∈B，且pi−bi与bi的法向量平行，而bi是曲面B上的任意一点，该点处于B上某一个三角形(a,b,c)∈B之中，因此bi可以表示为下列重心坐标的形式</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-30.png" alt=""></p>
<p>其法向量同样可以由重心坐标插值得到</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-31.png" alt=""></p>
<p>而寻找点b的过程，可以使用牛顿迭代法求解下面方程的根</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-32.png" alt=""></p>
<p>整个过程大致为，首先寻找离pi最近的三角形，如果在进行牛顿迭代的过程中重心坐标出现了负值，则分别对其相邻的三角形进行处理。</p>
<p>一旦得到了三角形(a,b,c)和重心坐标(α,β,γ)，则可以通过变形后的曲面B′计算出S′上每一个顶点pi的坐标</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-33.png" alt=""></p>
<p>这样避免了对曲面进行重采样，从而使得某些尖锐细小的特征(Sharp Features)得到保留。因为点 bi是曲面B上的任意一点，因此对于曲面S和B来说，其连接性并不一定要求是已知的。我们可以利用这一点来对曲面B进行重采样以获得更高的数值鲁棒性。</p>
<p>位移向量和法向量位移的长度的不同通常取决于曲面B和曲面S相差的程度，对于例子</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-34.png" alt=""></p>
<p>位移向量的长度平均比法向量位移的长度要长9倍。除了长度更短法向量位移也不需要进行启发式的计算(计算坐标基t的过程)。</p>
<p>法向量位移的方法效率极高，但是其主要的问题在于相邻的顶点的位移向量之间并没任何联系。当弯折(Bending)程度较大的时候，会导致细节部分出现非预期的结果。在极端情况曲面可能还能出现自相交的情况(当B′的曲率比位移长度hi要大的时候)。</p>
<p>下面的两种算法正是为了改进上述情况而提出的</p>
<ul>
<li>
<p><strong>Displacement Volumes</strong>：曲面S和曲面B对应的两个三角形(pi,pj,pl)和(bi,bj,bl)组成了一个棱柱体，该棱柱体的体积被用来作为细节D，在变形的过程中保持不变。对于变形的曲面B′，重建的过程是找到一个曲面S′使得其每一个棱柱体的体积都和原来的相等。这样会使得结果根据直观合理且避免了自相交的情况，缺点是该方法在重建的过程中计算量较大。</p>
</li>
<li>
<p><strong>Deformation Transfer</strong>：原书中没有详细介绍该算法，可以参考这篇论文<a target="_blank" rel="noopener" href="http://www.citmed.uni-bielefeld.de/publications/vmv06.pdf">Deformation Transfer for Detail-Preserving Surface Editing</a>。该算法在最终效果和运行效率上取了一个折中，只需要解一个疏松的泊松方程即可。</p>
</li>
</ul>
<h2 id="Differential-Coordinates">Differential Coordinates</h2>
<p>尽管前面的Multi-Scale Deformation方法效率高，且能够保存模型中的细节，但是如何生成一个合理的层级结构确是一个相当复杂的过程。为了避免Multi-Scale Deformation中分解的过程，另外一类方法采用了修改曲面的微分属性而不是空间坐标的方法来重建变形后的曲面。</p>
<h3 id="Gradient-Based-Deformation">Gradient-Based Deformation</h3>
<p>对于原始网格上每一个顶点上某个标量值，都可以找到对应的分段线性函数</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-35.png" alt=""></p>
<p>其梯度是一个常向量(每一个三角形T对应一个常向量)</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-36.png" alt=""></p>
<p>同样地，考虑以下三维的情况</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-37.png" alt=""></p>
<p>则对应每个三角形T，它的梯度是一个3*3的雅可比矩阵</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-38.png" alt=""></p>
<p>参考第三章中介绍的方法，可以计算出矩阵中的各个位置上梯度函数的值。</p>
<p>接下来对每一个三角形的梯度JT进行变形，即乘以一个3*3的变换矩阵(旋转、缩放/错切)MT</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-39.png" alt=""></p>
<p>MT是根据对控制点的变换得到，具体的方法会在后文中介绍。</p>
<p>剩下的步骤就是在尽量保持每一个三角形梯度不变得情况下，寻找每个顶点的新的位置。</p>
<p>如下图所示，黄色区域为控制点所在区域，原模型为圆柱体表面(左图)，我们对变换区域(蓝色区域)上每一个三角形施以对控制点相同的变换，这将使得模型“裂开”(中图)，然后改变每一个三角形的位置且尽量保持三角形的朝向不变，最终得到了变形后的模型(右图)。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-40.png" alt=""></p>
<p>这个过程即是最小化下列的能量函数</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-41.png" alt=""></p>
<p>f是待寻找的方程，g是目标梯度场。为了最小化上式子，应用变分法解下列欧拉拉格朗日方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-42.png" alt=""></p>
<p>用目标的的x, y, z坐标代替f，并用离散拉普拉斯算子和离散散度算子对原方程离散化得到线性方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-43.png" alt=""></p>
<p>为了使得方程有解(系统非奇异)，需要将固定一些点p′i，如示意图中黄色的控制区域H内的顶点(这也就是上面的示意图的中图里黄色区域的控制点的位置被直接修改的原因)、示意图中灰色的固定区域F内的顶点。</p>
<p>解上述方程只需要解一个输送的泊松方程，比前面的Shell-Based Deformation效率略高。另外，泊松方程在边界处只是C0连续的，但是Shell-Based Deformation是C1连续的。</p>
<h3 id="Laplacian-Based-Deformation">Laplacian-Based Deformation</h3>
<p>Laplacian-Based Deformation与Gradient-Based Deformation方法类似，不过其目标不再是逐三角形的梯度，而是逐顶点拉普拉斯坐标。</p>
<p>我们首先计算每个顶点的拉普拉斯坐标，然后乘以变换矩阵M，最后寻找新的顶点坐标去你和目标拉普拉斯坐标。</p>
<p>这个过程中最小化能量函数为</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-44.png" alt=""></p>
<p>对应的欧拉拉格朗日方程为</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-45.png" alt=""></p>
<p>上式离散化后得到下列方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-46.png" alt=""></p>
<p>在解方程的时候同样的需要固定一些顶点。需要注意的是，拉普拉斯算子的离散形式有Uniform和Cotangent两种，对于不规则网格使用后者得到的结果效果会更好一些。</p>
<p>Laplacian-Based Deformation方法和Shell-Based Deformation方法之间是存在联系的。忽略掉Laplacian-Based Deformation中对拉普拉斯坐标的变换，使用原始的拉普拉斯坐标来计算新的顶点的位置，在Shell-Based Deformation中固定相同的顶点且原始顶点相同，两者都能得到相同的欧拉拉格朗日方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-47.png" alt=""></p>
<p>则最终得到相同的结果。</p>
<h3 id="如何得到变换矩阵M">如何得到变换矩阵M</h3>
<p>那么前面两种方法中都使用到了变换矩阵M，这一节将会讨论如何根据对控制点的变换得到逐顶点和逐面(三角形)的变换矩阵</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-48.png" alt=""></p>
<h4 id="Propagation-Of-Deformation-Gradients">Propagation Of Deformation Gradients</h4>
<p>第一种方法和之前提到的Transformation Propagation中插值的方法类似，这里我们对变换的梯度进行插值。通常我们是按照下面的方式对控制点进行仿射变换</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-49.png" alt=""></p>
<p>T(x)的梯度是一个3*3的矩阵M，该矩阵代表了对控制点的旋转、缩放/错切变换。</p>
<p>需要注意的是，旋转变换的插值与缩放/错切变换不同，需要对变换矩阵进行 <strong>极分解(Polar Decomposition)</strong>。</p>
<p>首先对M进行奇异值分解，得到</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-50.png" alt=""></p>
<p>然后就能得到M矩阵中旋转的部分和缩放/错切的部分</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-51.png" alt=""></p>
<p>因为U和V是正交矩阵，所以有</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-52.png" alt=""></p>
<p>然后我们对旋转部分是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Slerp">slerp</a>插值，对缩放/错切的部分使用线性插值，得到逐顶点的变换矩阵Mi</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-53.png" alt=""></p>
<p>对于逐面(三角形)，其插值的因子s是三角形T的三个顶点对应的值si,sj,sk的平均值。需要注意的是，平移变换t并不会改变梯度和拉普拉斯坐标的值，所以当变换中包含有距离较大的平移变换的时候会产生不符合预期的结果。</p>
<h4 id="Implicit-Optimization">Implicit Optimization</h4>
<p>通过最小化下面能量函数，Implicit Optimization同时对新的顶点坐标p′i以及旋转矩阵Mi进行优化</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-54.png" alt=""></p>
<p>其中Ai是顶点的局部面积，Mi和新顶点的位置有关。注意这个过程中同样需要固定区域H和区域F中的顶点。</p>
<p>为了避免非线性最优化(Nonlinear Optimization)(这是刚体变换Mi中必须满足的)，局部变换被限制为相似线性变换(Linearized Similarity Transformation)，Mi被写成下面的斜对称矩阵</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-55.png" alt=""></p>
<p>参数si和hi(位移向量)是由下列限制条件决定</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-56.png" alt=""></p>
<p>通过p′i的线性组合可以得到si和hi。</p>
<p>书中对该部分介绍省略了很多，详细的内容可以参考这篇论文：<a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.360.5276&amp;rep=rep1&amp;type=pdf">Laplacian Surface Editing</a></p>
<p>需要注意的一点是，根据拉普拉斯坐标的性质，其对 <strong>旋转敏感</strong> ，所以网格的局部信息会发生旋转扭曲，且旋转尺度较大是，扭曲会非常严重。</p>
<h2 id="Freeform-Deformation">Freeform Deformation</h2>
<p>前面讨论的所有方法都是基于曲面的(Surface- Based)，它们通过最小化某个能量函数在原曲面S上进行光滑变形。其计算过程归结起来是解一个线性系统对应的欧拉拉格朗日方程。</p>
<p>上述方法的一个明显的缺点在于其计算量和数值鲁棒性和网格分割的复杂度和质量相关。对于退化的三角形(Degenerate Triangle)其Cotangent形式的拉普拉斯算子是不符合定义的，这会导致线性系统奇异。同样地，Gap和非流形的出现使得顶点地局部信息不再一致，也会导致一些问题。诸如模型修复或者网格重划分算法能够在一定程度上接近这些问题。纵使网格的质量足够高，但是其复杂过大也会导致线性系统规模过大无法得到其解。</p>
<p>接近这些问题的办法是使用 <strong>空间变形(Space Deformations)</strong> ，它通过对目标模型的周围空间进行变形从而隐式的对目标模型进行变形。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-57.png" alt=""></p>
<p>与 <strong>基于曲面的变形(Surface-Based Deformations)</strong> 不同，<strong>空间变形(Space Deformations)</strong> 的变形是一个从三维空间到另一个三维空间的过程。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-58.png" alt=""></p>
<p>且d不依赖于特定的曲面，能够作用用各种显式表示的曲面(三角形网格的所有顶点、点采样模型的所有点)。</p>
<h3 id="Lattice-Based-Freeform-Deformation">Lattice-Based Freeform Deformation</h3>
<p>Freeform Deformation(FFD)中使用3元张量样条函数(Trivariate Tensor-Product Spline Function)来表示空间变形</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-59.png" alt=""></p>
<p>其中Ni是B样条函数，δc是控制点c的位移量。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-60.png" alt=""></p>
<p>为了简化上式，可以将位移项和样条函数项记为</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-61.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-62.png" alt=""></p>
<p>最终得到</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-63.png" alt=""></p>
<p>原网格上的每一个顶点pi∈S都有一个对应的的参数坐标ui=(ui,vi,wi)，且</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-64.png" alt=""></p>
<p>每一个顶点都会被施以变换</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-65.png" alt=""></p>
<p>因为d(ui)中的N项是一个常数，可以预计算，所以其效率较高。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-66.png" alt=""></p>
<p>通过操纵样条控制点(即指定控制点位移δc)就能够控制模型的变形。和之前提到的方法类似，固定控制区域H(施加位移向量d之后的位置)和固定区域F内的顶点，然后根据给定的δc解下列线性方程</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-67.png" alt=""></p>
<p>由于方程左边的矩阵不是方阵，所以可以使用最小二乘法的思想，最小化</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-68.png" alt=""></p>
<p>以及控制点的位移量</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-69.png" alt=""></p>
<p>不过需要注意两个问题，首先如果上述方程是过定的(Over-Determined)，所以限制条件不能被完美地满足；另外如果是欠定的(Under-Determined)，剩余的自由度是由最小化控制点的位移量决定的，而不是通过光滑算法决定。</p>
<p>样条函数N在规则网格(Regular Grid)上如何放置是另外一个问题。如果放置不当，会造成Alias Artifacts(走样/假频)。通过使用更为灵活的且能够更好的表示目标变形的格子框架能够在一定程度上解决这个问题，但是面对复杂的变形的时候，格子框架的选取非常困难。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-70.png" alt=""></p>
<h3 id="Cage-Based-Freeform-Deformation">Cage-Based Freeform Deformation</h3>
<p>Cage-Based Freeform Deformation可以被看作是Lattice-Based Freeform Deformation的一般化情况。Cage-Based Freeform Deformation使用 <strong>控制笼(Control Cage)</strong> 而不是Lattice-Based Freeform Deformation中使用的规则的格子框架。这种控制笼通常是包围着待修改物体的任意三角形网格。相对于格子框架，其能够更好的包裹目标物体。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-71.png" alt=""></p>
<p>原始网格S上的顶点pi能够表示为控制笼上顶点的线性组合</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-72.png" alt=""></p>
<p>其中权重ϕ是广义重心坐标(Generalized Barycentric Coordinates)，可以取之前方程中的N项。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-73.png" alt=""></p>
<p>顶点的权重ϕ可以被预计算，这样通过操作控制笼上的顶点</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-74.png" alt=""></p>
<p>并使用下面的方法计算逐顶点的位移向量即可</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-75.png" alt=""></p>
<p>这样就能比之前使用格子框架能够更为灵活地进行控制。其缺点是由于解是最小范数解(Least Norm Solution)，所以结果并不一定是一个Fair Deformation(不知道怎么翻译)。</p>
<h2 id="Radial-Basis-Functions">Radial Basis Functions</h2>
<p>在Surface-Based Deformations中，通过指定地位移进行插值，并且最小化能量函数得到了相当不错的结果。借用同样的思想，同样地，我们可以对Space Deformation中的函数</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-76.png" alt=""></p>
<p>进行插值，并且最小化特定的能量函数。总的来说，我们的目标是找到函数d，能够在位置pi根据指定的位移向量进行插值运算，且满足给定的限制条件。Radial Basis Functions(RBFs)正是非常适合这类问题的函数。其定义为径向对称核函数ϕ的叠加，其中心为 cj，权重为wj</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-77.png" alt=""></p>
<p>其中π(x)为保证精度用的多项式项。通常取cj=pj，wj的值为下列方程的解</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-78.png" alt=""></p>
<p>这样RBF函数就能够被应用到顶点上了</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-79.png" alt=""></p>
<p>而核函数φ的选择会影响到计算的复杂度和结果的质量。紧支撑径向基函数(Compactly Supported Radial Basis Functions)会产生稀疏的线性方程，因此其能够被用来对加以很多限制条件的目标进行插值。其缺点在于效果不如全局支持径向基函数(Global Support Radial Basis Functions)。</p>
<p>全局支持径向基函数</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-80.png" alt=""></p>
<p>会产生一个三次(??不确定是不是这么翻译的)调和函数(Tri-Harmonic Function) d</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-81.png" alt=""></p>
<p>通过变分法可知，需要最小化的能量函数为</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-82.png" alt=""></p>
<h2 id="线性方法的局限性">线性方法的局限性</h2>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-83.png" alt=""></p>
<h4 id="原始模型">原始模型</h4>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-84.png" alt=""></p>
<h4 id="使用非线性方法得到的结果-从左往右分别是纯平移变形、弯折变形、扭曲变形">使用非线性方法得到的结果(从左往右分别是纯平移变形、弯折变形、扭曲变形)</h4>
<ul>
<li>Shell-Based Deformation结合Multi-Scale Deformation能在纯平移变形时得到较高质量的结果，且能够保留相当的细节。但是由于Shell Energy是线性的，当对物体施以大尺度旋转变形的时候，结果会非常不理想。</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-85.png" alt=""></p>
<h4 id="Shell-Based-Deformation得到的结果">Shell-Based Deformation得到的结果</h4>
<ul>
<li>Gradient-Based Deformation使用对控制点变换的梯度更新每一个面的梯度，因此在对物体施以旋转变形的时候结果会非常理想。但是由于局部旋转的显式传播(Propagation)是对平移敏感的，会导致结果曲面不够光滑，并且会丢失细节特征。</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-86.png" alt=""></p>
<h4 id="Gradient-Based-Deformation得到的结果">Gradient-Based Deformation得到的结果</h4>
<ul>
<li>Laplacian-Based Deformation隐式地优化了局部旋转，因此相对来说对旋转和平移变形更为友好。但是由于需要对旋转部分线性化，因此在大尺度变形时会导致扭曲。</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note9-Deformation/img-87.png" alt=""></p>
<h4 id="Laplacian-Based-Deformation得到的结果">Laplacian-Based Deformation得到的结果</h4>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">blauhimmel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">https://blauhimmel.github.io/tags/polygon-mesh-processing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归原作者所有，如有转载，请注明来自原作者</span></div></div><div class="post_share"><div class="social-share" data-image="/img/sea.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c25adb35.html" title="中科大-数字几何处理-网格重建与优化"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">中科大-数字几何处理-网格重建与优化</div></div></a></div><div class="next-post pull-right"><a href="/posts/dfe03bab.html" title="2021年度总结"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2021年度总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/850c08c.html" title="PMP-多边形网格处理-写在后面"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">PMP-多边形网格处理-写在后面</div></div></a></div><div><a href="/posts/85887e2a.html" title="PMP-多边形网格处理-曲面的表示"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">PMP-多边形网格处理-曲面的表示</div></div></a></div><div><a href="/posts/d5619342.html" title="PMP-多边形网格处理-网格数据结构"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-01</div><div class="title">PMP-多边形网格处理-网格数据结构</div></div></a></div><div><a href="/posts/6b345a08.html" title="PMP-多边形网格处理-参数化"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-07</div><div class="title">PMP-多边形网格处理-参数化</div></div></a></div><div><a href="/posts/1ba09c44.html" title="PMP-多边形网格处理-曲面平滑"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-16</div><div class="title">PMP-多边形网格处理-曲面平滑</div></div></a></div><div><a href="/posts/820ec93f.html" title="PMP-多边形网格处理-微分几何"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-26</div><div class="title">PMP-多边形网格处理-微分几何</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/m.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MrMatrix</div><div class="author-info__description">To be a better man.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">76</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TaylorAmy1995"><i></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com" target="_blank" title=""><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://www.zhihu.com" target="_blank" title=""><i class="iconfont icon-zhihu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个博客是为了记录自己在科研👨‍🔬、工作👨‍💻和生活👨‍👩‍👧‍👦的过程中捕获到的有价值的课程📺、书籍📗与事件📰，是面向我自己搭建的查漏补缺的备忘录📝和记事本📓✏️。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Transformation-Propagation"><span class="toc-number">1.</span> <span class="toc-text">Transformation Propagation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E6%A8%A1%E5%9E%8B-%E5%B7%A6-%EF%BC%9B%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E6%B3%95%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C-%E4%B8%AD-%EF%BC%9B%E7%90%86%E6%83%B3%E7%9A%84%E7%BB%93%E6%9E%9C-%E5%8F%B3"><span class="toc-number">1.0.1.</span> <span class="toc-text">原模型(左)；使用插值法计算结果(中)；理想的结果(右)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Based-Deformation"><span class="toc-number">2.</span> <span class="toc-text">Shell-Based Deformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi-Scale-Deformation"><span class="toc-number">3.</span> <span class="toc-text">Multi-Scale Deformation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB%E5%90%91%E9%87%8F-Displacement-Vectors"><span class="toc-number">3.1.</span> <span class="toc-text">位移向量(Displacement Vectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E5%90%91%E9%87%8F%E4%BD%8D%E7%A7%BB-Normal-Displacements"><span class="toc-number">3.2.</span> <span class="toc-text">法向量位移(Normal Displacements)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Differential-Coordinates"><span class="toc-number">4.</span> <span class="toc-text">Differential Coordinates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradient-Based-Deformation"><span class="toc-number">4.1.</span> <span class="toc-text">Gradient-Based Deformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Laplacian-Based-Deformation"><span class="toc-number">4.2.</span> <span class="toc-text">Laplacian-Based Deformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5M"><span class="toc-number">4.3.</span> <span class="toc-text">如何得到变换矩阵M</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Propagation-Of-Deformation-Gradients"><span class="toc-number">4.3.1.</span> <span class="toc-text">Propagation Of Deformation Gradients</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implicit-Optimization"><span class="toc-number">4.3.2.</span> <span class="toc-text">Implicit Optimization</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Freeform-Deformation"><span class="toc-number">5.</span> <span class="toc-text">Freeform Deformation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lattice-Based-Freeform-Deformation"><span class="toc-number">5.1.</span> <span class="toc-text">Lattice-Based Freeform Deformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cage-Based-Freeform-Deformation"><span class="toc-number">5.2.</span> <span class="toc-text">Cage-Based Freeform Deformation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Radial-Basis-Functions"><span class="toc-number">6.</span> <span class="toc-text">Radial Basis Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E6%B3%95%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">线性方法的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.0.1.</span> <span class="toc-text">原始模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E6%B3%95%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C-%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E5%88%86%E5%88%AB%E6%98%AF%E7%BA%AF%E5%B9%B3%E7%A7%BB%E5%8F%98%E5%BD%A2%E3%80%81%E5%BC%AF%E6%8A%98%E5%8F%98%E5%BD%A2%E3%80%81%E6%89%AD%E6%9B%B2%E5%8F%98%E5%BD%A2"><span class="toc-number">7.0.2.</span> <span class="toc-text">使用非线性方法得到的结果(从左往右分别是纯平移变形、弯折变形、扭曲变形)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell-Based-Deformation%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">7.0.3.</span> <span class="toc-text">Shell-Based Deformation得到的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gradient-Based-Deformation%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">7.0.4.</span> <span class="toc-text">Gradient-Based Deformation得到的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Laplacian-Based-Deformation%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">7.0.5.</span> <span class="toc-text">Laplacian-Based Deformation得到的结果</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6382afc7.html" title="观陶哲轩演讲-AI与数学-后有感">观陶哲轩演讲-AI与数学-后有感</a><time datetime="2024-08-29T16:00:00.000Z" title="发表于 2024-08-30 00:00:00">2024-08-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b9a84247.html" title="国科大-随机过程-写在后面">国科大-随机过程-写在后面</a><time datetime="2024-01-28T16:00:00.000Z" title="发表于 2024-01-29 00:00:00">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4309bd24.html" title="国科大-随机过程-连续时间马尔可夫链">国科大-随机过程-连续时间马尔可夫链</a><time datetime="2024-01-27T16:00:00.000Z" title="发表于 2024-01-28 00:00:00">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b497123d.html" title="国科大-随机过程-马尔可夫链的转移概率与极限行为">国科大-随机过程-马尔可夫链的转移概率与极限行为</a><time datetime="2024-01-20T16:00:00.000Z" title="发表于 2024-01-21 00:00:00">2024-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8d52a7e7.html" title="国科大-随机过程-马尔可夫链中的常反性及其相关概念">国科大-随机过程-马尔可夫链中的常反性及其相关概念</a><time datetime="2024-01-15T16:00:00.000Z" title="发表于 2024-01-16 00:00:00">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sea.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By MrMatrix</div><div class="icp"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>浙ICP备2024121111号</span></a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/"><img class="icp-icon" src="http://www.beian.gov.cn/img/new/gongan.png"/><span>浙公网安备33010802013618号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams'
        },
        chtml: {
          scale: 1.1
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div><script src="/js/category.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":false},"react":{"opacity":0.85},"log":false});</script></body></html>