<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PMP-多边形网格处理-模型修复 | MM's Journal of Technology</title><meta name="author" content="MrMatrix"><meta name="copyright" content="MrMatrix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="所谓模型修复，就是取“矫正”模型的一些“畸形”的地方(Artifacts)。 一些比较常见的“畸形”的情景有：   一般我们将模型修复算法粗略的分为下面两类： Surface-Oriented Algorithm 这类算法通常直接对输入的数据进行操作并通过修改曲面直接将“畸形”的地方(Artifacts)“矫正”。 如果是“沟(Gap)”，我们可以通过调整边界处的顶点和边的位置将两条边界边界“缝合">
<meta property="og:type" content="article">
<meta property="og:title" content="PMP-多边形网格处理-模型修复">
<meta property="og:url" content="http://mmwiki.cn/posts/36d5e38e.html">
<meta property="og:site_name" content="MM&#39;s Journal of Technology">
<meta property="og:description" content="所谓模型修复，就是取“矫正”模型的一些“畸形”的地方(Artifacts)。 一些比较常见的“畸形”的情景有：   一般我们将模型修复算法粗略的分为下面两类： Surface-Oriented Algorithm 这类算法通常直接对输入的数据进行操作并通过修改曲面直接将“畸形”的地方(Artifacts)“矫正”。 如果是“沟(Gap)”，我们可以通过调整边界处的顶点和边的位置将两条边界边界“缝合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mmwiki.cn/img/sea.jpg">
<meta property="article:published_time" content="2022-01-04T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-03T08:45:31.980Z">
<meta property="article:author" content="MrMatrix">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="数字几何处理">
<meta property="article:tag" content="多边形网格处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mmwiki.cn/img/sea.jpg"><link rel="shortcut icon" href="/img/m.png"><link rel="canonical" href="http://mmwiki.cn/posts/36d5e38e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PMP-多边形网格处理-模型修复',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 16:45:31'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/zhihu.css" media="defer" onload="this.media='all'"><!-- 其他 head 内容--><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/m.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">189</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">63</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/sea.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MM's Journal of Technology"><img class="site-icon" src="/img/m.png" alt="Logo"/><span class="site-name">MM's Journal of Technology</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PMP-多边形网格处理-模型修复</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-01-04T16:00:00.000Z" title="发表于 2022-01-05 00:00:00">2022-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/PMP-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">PMP-多边形网格处理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/">数字几何处理</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86/">多边形网格处理</a></div></div><article class="post-content" id="article-container"><p>所谓模型修复，就是取“矫正”模型的一些“畸形”的地方(Artifacts)。</p>
<p>一些比较常见的“畸形”的情景有：</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-0.png" alt=""></p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-1.png" alt=""></p>
<p>一般我们将模型修复算法粗略的分为下面两类：</p>
<h4 id="Surface-Oriented-Algorithm">Surface-Oriented Algorithm</h4>
<p>这类算法通常直接对输入的数据进行操作并通过修改曲面直接将“畸形”的地方(Artifacts)“矫正”。</p>
<p>如果是“沟(Gap)”，我们可以通过调整边界处的顶点和边的位置将两条边界边界“缝合”起来。</p>
<p>如果是“洞(Hole)”，我们将空白的部分进行三角剖分，从而补上它。</p>
<p>如果是“相交(Intersection)”，我们可以将相交出的三角形和边拆分(Split)。</p>
<p>算法只会额外添加很少的三角形。且不会修改其它正常区域。与此同时还能够较好地保留和顶点、三角形相关联的属性(连接性、纹理等)。</p>
<p>为了保证有效的输出，该算法对输入的模型会有一定的要求，故在执行算法之前和之后还需要我们进行一些手动处理。此外，由于存在精度上的问题，诸如 <strong>相交(Intersection)</strong> 和 <strong>大范围重叠(Large Overlap)</strong> 之类的地方不能被很好地修复，其它的例如在两个非常接近的曲面间产生的 <strong>沟(Gap)</strong> 往往不能够被检测到。</p>
<h4 id="Volumetric-Algorithm">Volumetric Algorithm</h4>
<p>该算法将输入的模型用测定体积的方式去表示它(简单地说就是该模型占据了空间的哪些区域)。然后根据前面的表示形式，从中提取输出的模型。</p>
<p>所谓测定体积的方式，即将空间划分为一小块一小块，对于每一个小块我们赋予其下面三种状态之一的状体：模型内、模型外和与模型相交。</p>
<p>常见的方法有：根据笛卡尔坐标进行划分、自适应八叉树、KD树、BSP树和3D德洛内三角剖分。</p>
<p>该算法不需要手动进行处理，且输出的模型是完全严丝合缝的(Watertight Model)，能够修复除了 <strong>Handle</strong> 外的其它类型的“畸形”。不过这种类型的“畸形”也可以通过一定方法移除掉。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-2.png" alt=""></p>
<p>从整体上看，算法相当于是对输入的模型进行了一次重采样，因而会造成诸如走样(Alias)、丢失模型特征的问题，并且模型上基于原有网格连接性的相关属性信息也会丢失。因为输出模型的三角形的数目会比输入模型的要多，所以还需要对输出的模型进行简化。并且算法是比较耗费内存的，所以往往很难再高分辨率的模型上运行。</p>
<h3 id="输入类型">输入类型</h3>
<p>下面介绍一些常用的模型输入类型以及该类型通常会产生的“畸形”的类型。</p>
<h4 id="Registered-Range-Scan">Registered Range Scan</h4>
<p>Registered Range Scan是一系列相互重叠的面片，这些面片可以用来表示输入模型。在将这些面片融合为一个单一的三角形网格的时候就由可能出现问题。由于输入数据中存在较大的重叠，所以曲面上的某一个点x会被若干个面片表示。并且每一个面片都有自己的连接性属性，这些属性和其它的面片并不兼容。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-3.png" alt=""></p>
<h4 id="Fused-Range-Scan">Fused Range Scan</h4>
<p>Fused Range Scan是带边界(如Gap、Hole和Island)的流形(Manifold)网格。这些边界是由于扫描仪的实现上出现了遮挡物或者物体表面上的一些特殊属性，如透明或者高光造成的。我们的目标是找到并填补上这些洞(Hole)。更加高级的算法不仅仅是填上这些洞(Hole)，而且还根据该区域周围的几何特征为这个区域合成新的几何特征。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-4.png" alt=""></p>
<h4 id="Triangle-Soup">Triangle Soup</h4>
<p>Triangle Soup是三角形的集合，并且几乎没有这些三角形的连接性信息。Triangle Soup通常出现在CAD建模中，由用户手动建立(通过一些已经定义好的元素来创建出目标模型的边界)。模型虽然只是由三角形构成，却可能出现各种类型的“畸形”。其中“相交(Intersection)”是最为常见的，对其的检测过程非常耗时。所以该类型通常多用于可视化而不是几何处理。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-5.png" alt=""></p>
<h4 id="Triangulated-NURBS-Patch">Triangulated NURBS Patch</h4>
<p>Triangulated NURBS Patch是一系列三角形网格的集合，最终的模型由这些网格拼接得到。所以在将不同的网格拼合的时候，拼合处就可能会出现“沟(Gap)”和小的“重叠(Overlap)”。并且在结合处还有可能出现法线方向不一致的情况。通常我们使用<strong>Surface-Oriented Algorithm</strong>来修复它。首先要确保输出的每一块网格的朝向一直，然后在将相邻两块网格咬合(Snap)在一起。</p>
<h4 id="Contoured-Mesh">Contoured Mesh</h4>
<p>Contoured Mesh是通过体积测定数据集(Volumetric Dataset)导出的网格模型。理论上导出的模型是一个流形(Manifold)，并且是密闭的(Watertight)。然而也会出现像下图那样的“畸形”(书中称之为 <strong>Small Spurious Handle</strong> )。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-6.png" alt=""></p>
<p>体积测定数据(Volumetric Data)通常出现在构造实体几何(Constructive Solid Geometry)中，或者在医学图像(CT，核磁共振等)中用作某种中间表示形式。在数据集中的每一个点通常会被赋于一个标量值，负值代表在物体内部，正值代表在物体外部，零值则代表在物体表面上，这些点通常也被称为 <strong>体像素(Voxel)</strong>。</p>
<p>由于分辨率有限，体像素通常不能够被正确的分类(内部、外部还是表面上)，导致 <strong>Partial Volume Effect</strong> ，简单的说就是因为显示粒度相对于数据集中的点来说太大或者太小了导致无法对其进行正常的分类。举个例子，我们知道大脑皮层与球面同胚(能够展开为球面)，但是在我们通过CT扫描的数据导出的模型中一些实际上是分离的地方往往都糊成了一团。</p>
<p>对于 <strong>Handle</strong> 类的“畸形”，我们往往是在原数据集进行处理以修复它，然后在提取出结果模型。然后在对模型进行处理以修复其它的“畸形”。</p>
<h4 id="Badly-Meshed-Manifold">Badly Meshed Manifold</h4>
<p>Badly Meshed Manifold是指包含了退化元素(Degenerate Element)的网格，如：</p>
<ul>
<li>面积为0的三角形</li>
<li>有一个内角为π(称为 <strong>Cap</strong> )</li>
<li>有一条边的长度为0(称为 <strong>Needle</strong> )</li>
<li>相邻三角形的法向量的夹角接近π(称为 <strong>Triangle Flip</strong> )</li>
</ul>
<p>改善这类网格的方法一般是 <strong>网格重划分(Remeshing)</strong>。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-7.png" alt=""></p>
<h2 id="Surface-Oriented-Algorithm-2">Surface-Oriented Algorithm</h2>
<p>Surface-Oriented Algorithm直接对输入的网格进行修改，以对其进行显示修复。</p>
<h3 id="Surface-Based-Hole-Filling">Surface-Based Hole Filling</h3>
<p>这里介绍的补洞算法是其它类似算法的基础。我们的目标是得到一个三角形网格，网格的边界是一个给定的多边形p0,…,pn−1，该多边形能够正好放入待修复的“洞(Hole)”中。随后我们还需根据一些与网格属性(如面积，三角形法线的变化程度，曲率分布等)相关的质量函数去优化这块网格。</p>
<p>假设ψ(i,j,k)是定义在三角形(pi,pj,pk)上质量函数，ω(i,j)是多边形p0,…,pn−1的子多边形 pi,…,pj经过三角剖分后得到网格的最优质量，ω(i,j)可以通过下面的迭代式递归的计算出来</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-8.png" alt=""></p>
<p>其中整体的最优质量ω(0,n−1)能够通过动态规划算法计算得到。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-9.png" alt=""></p>
<p>函数ψ(i,j,k)应该考虑下面两个因素：</p>
<ul>
<li>Δijk和其周围三角形组成的二面角(等价于法向量的变化程度)</li>
<li>Δijk的面积</li>
</ul>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-10.png" alt=""></p>
<h4 id="α是最大的二面角，A是△ijk的面积">α是最大的二面角，A是△ijk的面积</h4>
<p>并且第一个因素的决定程度更高，所以</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-11.png" alt=""></p>
<p>可以发现，我们在评估一个三角形的质量的时候考虑到了其周围的三角形。这些三角形可能是原来已经有的，也可能是新创建出来。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-12.png" alt=""></p>
<p>在填补完成后，我们还需要对填补上去的网格进行一些调整，使得其顶点分布的密度以及边的平均长度于其周围的网格相匹配。</p>
<p>算法构建三角剖分的时间复杂度为O(n3)，由于“洞(Hole)”一般不大，所以这是可以接受的。然而算法并不能“矫正”“自我相交(Self Intersection)”的问题。</p>
<h3 id="Gap-Closing">Gap Closing</h3>
<p>对于“沟(Gap)”，我们可以将其看成一个特殊的“洞(Hole)”，使用上面介绍算法来进行修复。</p>
<p>另外可以做从点到边的收缩(Vertex-Edge Contraction)操作。假定我们将顶点v收缩指边界e上，设c是e上离v最近的点，如果c是e内部的顶点，则将c插入到e上，并将相邻的那个三角形一分为二。最后再将v和c合并即可。可以使用v到c的距离来作为收缩操作的误差。算法还维护着一个优先队列，优先队列存储的是一对顶点和边，优先级使用的是前面提到的误差。然后按优先级从小到大进行相应的收缩操作。</p>
<p>上述算法本身是完备的，且易于实现。如果输入的模型和设定的阈值比较理想，一般能够得到比较理想的结果。不过往往实际情况并非这么理想，由于算法本身是启发式的，所以输出的模型上可能还是会存在各种“畸形”的地方(Artifacts)。所以算法往往被设定为迭代循环的形式，让用户来引导，使算法向着期望的地方进行迭代。</p>
<h3 id="Topology-Simplification">Topology Simplification</h3>
<p>拓扑简化的目的就是为了移除网格上的 <strong>Handle</strong> ，算法的基本思想如下图所示：首先将 <strong>Handle</strong> 沿着绿线切开，切开后模型上会出现两个“洞(Hole)”，然后使用之前提到的算法将这两个“洞(Hole)”给补上。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-13.png" alt=""></p>
<p>给定一个初始三角形s，算法通过对原网格执行Dijkstra算法计算得到s周围的Geodesic Region Rϵ(s)。Dijkstra算法在计算得到最短路径的同时，还能得到每一个三角形到初始三角形 <em>s</em> 的最短路径上的上一个三角形(Parent Triangle)，记作p(t)，p(t)的上一个三角形记作p2(t)…依此类推，路径上的最后一个点为s 。</p>
<p>Rϵ(s) 包含一个或多个环状边界，当有一个环状边界在某一条边上触碰到自己的时候，就将它分裂为两个新环。如果是两个不同的环在e12处相互触碰的时候就表示我们检测到了 <strong>Handle</strong> 。假设t1,t2是与e12相邻的两个三角形，假设t1和t2存在一个共同的祖先</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-14.png" alt=""></p>
<p>则该 <strong>Handle</strong> 可以由下面的闭合路径确定</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-15.png" alt=""></p>
<p>然后我们沿着该路径将模型切开，并补上新产生的两个“洞(Hole)”。</p>
<p>为了检测原网格中的所有 <strong>Handle</strong> ，我们必须对所有的三角形s执行上面的算法，所以算法的效率不高。并且算法不能检测到长的(long)、薄的(thin) <strong>Handle</strong> ，并且不能保证在 <strong>Handle</strong> 被移除后不存在几何自相交的情况。</p>
<h2 id="Volumetric-Repair-Algorithms">Volumetric Repair Algorithms</h2>
<h3 id="Volumetric-Repair-on-Regular-Grids">Volumetric Repair on Regular Grids</h3>
<p>这种方法能够修复包含有 <strong>Gap</strong> 、 <strong>Overlap</strong> 以及 <strong>Intersections</strong> 的模型，对于 <strong>Hole</strong> 和 <strong>Handle</strong> ，该方法使用形态学操作(Morphological Operators)来对其进行处理。</p>
<p>算法分为两步，第一步是进行体素化。首先生成 <strong>投影方向集合</strong> {di}(如通过细分八面体或者二十面体)。接下来将模型沿着正交平面网格(Orthogonal Planar Grid)的方向进行投影。对于网格上的每一个点x ，算法会记录射线x+λdi与输入模型的第一个和最后一个交点。位于两者之间体像素(voxel)被分类是处于内部点，其它的体像素(voxel)被分类为外部。每一个体像素会被不同的射线进行分类，最终的分类结果按照少数服从多数的原则选取。</p>
<p>第二个步骤是可选的，通过形态学操作(Morphological Operators)将 <strong>Handle</strong> 和 <strong>Hole</strong> 进行修复。这个过程会用到 <strong>膨胀(Dilation)</strong> 和 <strong>腐蚀(Erosion)</strong> 操作。对于膨胀操作，考虑被分类为内部的顶点组成的集合，将所有与该集合距离小于特定值的外部体像素的分类设置为内部。而腐蚀操作则与膨胀操作正好相反。</p>
<p>该算法是启发性的，通常不是非常的可靠，并且不是特征敏感(Feature sensitive)的，即某些特征可能在修复后丢失。</p>
<h3 id="Volumetric-Repair-on-Adaptive-Grids">Volumetric Repair on Adaptive Grids</h3>
<p>可以使用八叉树代替规则网格以改进上述算法。在改进的算法中会使用下面两个限制变量：容忍度ε和最大修复直径ρ(描述需要修复多宽的Gap)。</p>
<p>首先使用八叉树对输入的模型进行划分，ϵ在这里表示节点的最小直径。接下来对八叉树子节点进行分类(处于内部还是外部)。然后对处于模型边界上的节点进行 <strong>膨胀(Dilation)</strong> 操作，膨胀的距离为n=ρϵ，这样直径小于ρ的Gap将会被修复。下一步，从外部向内部进行 <strong>膨胀(Dilation)</strong> 操作，以抵消前一步带来的模型体积的增大。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-16.png" alt=""></p>
<h4 id="紫色方格代表边界上的节点，绿色表示膨胀边界过程中影响到的节点，橙色表示从外部向内部膨胀过程中影响到的节点">紫色方格代表边界上的节点，绿色表示膨胀边界过程中影响到的节点，橙色表示从外部向内部膨胀过程中影响到的节点</h4>
<p>接下来使用Dual Contouring算法通过采样点进行重建工作即可。采样点通常取与三角形所在平面的平方距离最小值的点(模型简化那一章提到过)，如果找不到这样的平面(节点是通过膨胀操作得到的)，则可以通过平滑算子(Smoothing Operator)来采样得到采样点。</p>
<p>改进算法能够保证输出是一个流形(Manifold)，并且特征能够得到保留，但是重建的分辨率是有限的。</p>
<h3 id="Volumetric-Repair-with-BSP-Trees">Volumetric Repair with BSP Trees</h3>
<p>该算法使用BSP树，每一个输入多边形(三角形)所在的平面作为其划分平面，树的子节点对应了一个凸多边形Ci。对于每一个凸多边形Ci，定义并计算出一个从-1到1的 <strong>硬度系数(Solidity Coefficient)</strong> si 。-1表示区域为空(不属于网格内部)，1表示则表示其属于区域内部。</p>
<p>所有无限大的区域都可以被看作是处于物体的外部，因此其 <strong>硬度系数(Solidity Coefficient)</strong> 的值为-1。</p>
<p>设Ci为有限区域，N(i)表示于其相邻的面的集合。那么对于j∈N(i)，交集Pij=Ci∩Cj表示两区域相交部分多边形所在的平面，tij表示区域边界平面上不被输入多边形(三角形)包含的部分的面积(称之为透明的)，oij表示区域边界平面上被输入多边形(三角形)包含的部分的面积(称之为不透明的)，aij表示平面的总面积。那么si与和其相邻的sj的关系可以写成</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-17.png" alt=""></p>
<p>其中Ai表示区域Ci边界的面积之和</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-18.png" alt=""></p>
<p>通过观察可以发现如果两个区域相交平面大部分为透明的，则有很大的可能它们都是处于内部或者都是处于外部的。如果大部分区域为不透明的，则有很大可能其中一方处于内部而另一方处于外部。</p>
<p>上面的式子可以写成下面的矩阵的形式</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-19.png" alt=""></p>
<p>最终通过枚举所有的区域Ci，如果其中一方是处于内部的而另一方是处于外部的，则将其边界Pij加入到重建的过程中。</p>
<p>该算法不需要用户指定一些额外的参数，并且可以得到严丝合缝的模型(Watertight Model)。得到的结果中可能包含有 <strong>Complex Edge</strong> 和 <strong>Singular Vertex</strong> (参考开篇的图片)，这些可以使用前面提到的方法进行修复。不过，很难找到即具有鲁棒性又具有高效性的的BSP结构。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-20.png" alt=""></p>
<h4 id="BSP树-左-，硬度系数-中-，重建-右">BSP树(左)，硬度系数(中)，重建(右)</h4>
<h3 id="Volumetric-Repair-on-the-Dual-Grid">Volumetric Repair on the Dual Grid</h3>
<p>该算法首先使用坐标系网格所有面的一个子集F来近似输入模型，为了节约内存，可以使用八叉树来辅助这个过程。同时将采样点(和法向量)附在每一个面上，以方便后面进行一些更精确的操作。</p>
<p>对于子集F，其边界∂F可以定义为指向奇数个面的坐标系网格边的集合(如下图中红色圆点)。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-21.png" alt=""></p>
<p>对于每一个边界上的回路Bi，接下来我们寻找另一个集合G，集合G与Bi相同，且它们的对称差集的边界为空集。然后将F进行替换，直到F的边界为空集。</p>
<p><img src="/img/post/pmp/Polygon-Mesh-Processing-note8-Repair/img-22.png" alt=""></p>
<p>最后只需要使用Marching Cubes或者Dual Contouring算法进行最后的重建工作即可。</p>
<p>该算法能够保证输出是一个流形(Manifold)，并且算法的内存效率较高能够适应较大的数据量。但是在一些特殊结构，如待修复的 <strong>Hole</strong> 与输入的几何机构存在重合的时候，网格可能会变成几个不相连的部分。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">blauhimmel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blauhimmel.github.io/tags/polygon-mesh-processing/">https://blauhimmel.github.io/tags/polygon-mesh-processing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归原作者所有，如有转载，请注明来自原作者</span></div></div><div class="post_share"><div class="social-share" data-image="/img/sea.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/dfe03bab.html" title="2021年度总结"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2021年度总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/13166e1a.html" title="中科大-数字几何处理-网格重建与REMESHING过程"><img class="cover" src="/img/sea.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">中科大-数字几何处理-网格重建与REMESHING过程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/850c08c.html" title="PMP-多边形网格处理-写在后面"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">PMP-多边形网格处理-写在后面</div></div></a></div><div><a href="/posts/85887e2a.html" title="PMP-多边形网格处理-曲面的表示"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">PMP-多边形网格处理-曲面的表示</div></div></a></div><div><a href="/posts/d5619342.html" title="PMP-多边形网格处理-网格数据结构"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-01</div><div class="title">PMP-多边形网格处理-网格数据结构</div></div></a></div><div><a href="/posts/1ba09c44.html" title="PMP-多边形网格处理-曲面平滑"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-16</div><div class="title">PMP-多边形网格处理-曲面平滑</div></div></a></div><div><a href="/posts/6b345a08.html" title="PMP-多边形网格处理-参数化"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-07</div><div class="title">PMP-多边形网格处理-参数化</div></div></a></div><div><a href="/posts/820ec93f.html" title="PMP-多边形网格处理-微分几何"><img class="cover" src="/img/sea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-26</div><div class="title">PMP-多边形网格处理-微分几何</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/m.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MrMatrix</div><div class="author-info__description">To be a better man.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">189</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">目录</div><div class="length-num">63</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.zhihu.com/people/MrMatrix"><i></i><span>知乎</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个博客是为了记录自己在科研、工作的过程中捕获到的有价值的课程与书籍，是面向我自己搭建的查漏补缺的备忘录和记事本</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Surface-Oriented-Algorithm"><span class="toc-number">1.</span> <span class="toc-text">Surface-Oriented Algorithm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Volumetric-Algorithm"><span class="toc-number">2.</span> <span class="toc-text">Volumetric Algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">输入类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Registered-Range-Scan"><span class="toc-number">1.</span> <span class="toc-text">Registered Range Scan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fused-Range-Scan"><span class="toc-number">2.</span> <span class="toc-text">Fused Range Scan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Triangle-Soup"><span class="toc-number">3.</span> <span class="toc-text">Triangle Soup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Triangulated-NURBS-Patch"><span class="toc-number">4.</span> <span class="toc-text">Triangulated NURBS Patch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Contoured-Mesh"><span class="toc-number">5.</span> <span class="toc-text">Contoured Mesh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Badly-Meshed-Manifold"><span class="toc-number">6.</span> <span class="toc-text">Badly Meshed Manifold</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface-Oriented-Algorithm-2"><span class="toc-number"></span> <span class="toc-text">Surface-Oriented Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Surface-Based-Hole-Filling"><span class="toc-number"></span> <span class="toc-text">Surface-Based Hole Filling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%CE%B1%E6%98%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BA%8C%E9%9D%A2%E8%A7%92%EF%BC%8CA%E6%98%AF%E2%96%B3ijk%E7%9A%84%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.</span> <span class="toc-text">α是最大的二面角，A是△ijk的面积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gap-Closing"><span class="toc-number"></span> <span class="toc-text">Gap Closing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topology-Simplification"><span class="toc-number"></span> <span class="toc-text">Topology Simplification</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volumetric-Repair-Algorithms"><span class="toc-number"></span> <span class="toc-text">Volumetric Repair Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Volumetric-Repair-on-Regular-Grids"><span class="toc-number"></span> <span class="toc-text">Volumetric Repair on Regular Grids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volumetric-Repair-on-Adaptive-Grids"><span class="toc-number"></span> <span class="toc-text">Volumetric Repair on Adaptive Grids</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AB%E8%89%B2%E6%96%B9%E6%A0%BC%E4%BB%A3%E8%A1%A8%E8%BE%B9%E7%95%8C%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E7%BB%BF%E8%89%B2%E8%A1%A8%E7%A4%BA%E8%86%A8%E8%83%80%E8%BE%B9%E7%95%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BD%B1%E5%93%8D%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E6%A9%99%E8%89%B2%E8%A1%A8%E7%A4%BA%E4%BB%8E%E5%A4%96%E9%83%A8%E5%90%91%E5%86%85%E9%83%A8%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BD%B1%E5%93%8D%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">紫色方格代表边界上的节点，绿色表示膨胀边界过程中影响到的节点，橙色表示从外部向内部膨胀过程中影响到的节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volumetric-Repair-with-BSP-Trees"><span class="toc-number"></span> <span class="toc-text">Volumetric Repair with BSP Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BSP%E6%A0%91-%E5%B7%A6-%EF%BC%8C%E7%A1%AC%E5%BA%A6%E7%B3%BB%E6%95%B0-%E4%B8%AD-%EF%BC%8C%E9%87%8D%E5%BB%BA-%E5%8F%B3"><span class="toc-number">1.</span> <span class="toc-text">BSP树(左)，硬度系数(中)，重建(右)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volumetric-Repair-on-the-Dual-Grid"><span class="toc-number"></span> <span class="toc-text">Volumetric Repair on the Dual Grid</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6382afc7.html" title="观陶哲轩演讲-AI与数学-后有感">观陶哲轩演讲-AI与数学-后有感</a><time datetime="2024-08-29T16:00:00.000Z" title="发表于 2024-08-30 00:00:00">2024-08-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b9a84247.html" title="国科大-随机过程-写在后面">国科大-随机过程-写在后面</a><time datetime="2024-01-28T16:00:00.000Z" title="发表于 2024-01-29 00:00:00">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4309bd24.html" title="国科大-随机过程-连续时间马尔可夫链">国科大-随机过程-连续时间马尔可夫链</a><time datetime="2024-01-27T16:00:00.000Z" title="发表于 2024-01-28 00:00:00">2024-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b497123d.html" title="国科大-随机过程-马尔可夫链的转移概率与极限行为">国科大-随机过程-马尔可夫链的转移概率与极限行为</a><time datetime="2024-01-20T16:00:00.000Z" title="发表于 2024-01-21 00:00:00">2024-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8d52a7e7.html" title="国科大-随机过程-马尔可夫链中的常反性及其相关概念">国科大-随机过程-马尔可夫链中的常反性及其相关概念</a><time datetime="2024-01-15T16:00:00.000Z" title="发表于 2024-01-16 00:00:00">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sea.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By MrMatrix</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn"><span>浙ICP备2024121111号</span></a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/"><img class="icp-icon" src="http://www.beian.gov.cn/img/new/gongan.png"/><span>浙公网安备33010802013618号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams'
        },
        chtml: {
          scale: 1.1
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div><script src="/js/category.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":false},"react":{"opacity":0.85},"log":false});</script></body></html>